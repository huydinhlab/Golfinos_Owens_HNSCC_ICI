---
title: "HNC Supplemental Figures"
author: "Athena Golfinos-Owens"
date: "2025-02-03" "updated 2025-10-03" 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(DescTools)
library(Seurat)
library(tidyr)
library(ComplexHeatmap)
library(circlize)
library(ggplot2)
library(cowplot)
library(ggpmisc)
library(ggpubr)
library(ggprism)
library(grid)

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 
print(getwd())
```

```{r Metadata add: Preparation for Cell Composition Heatmap--CosMx RNA Neighborhood Coordination}
## Object load-in
```{r}
# loading in necessary objects
```
rna_k10 <- read.csv('NeighborhoodCoordination/CosMx_RNA/Neighborhood_Coordination_CosMxRNA/WindowSize10/cells20neighborhoods.csv', row.names = 1) %>% 
  select(c('neighborhood10'))
colnames(rna_k10) <- 'k10_NhCoord20'

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

CosMX_RNA_merged <- AddMetaData(CosMX_RNA_merged, metadata = rna_k10)

CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20 %in% c('9') ~ 'Myeloid_K17+_Tumor_Mixed',
      CosMX_RNA_merged$k10_NhCoord20 %in% c('12') ~ "Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('8', '17') ~ "Tumor_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('5') ~ "DC_T_iCAF_Tumor_Mixed",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('10') ~ 'CAF_Immune_Mixed',
      CosMX_RNA_merged$k10_NhCoord20 %in% c('19') ~ "Endothelial",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('16', '18') ~ "CAFs",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('3', '15') ~ "Bcell_Plasma",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('4', '7', '0', '13', '6', '1', '11', '2', '14') ~ 'Tumor_High',
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20)
    ),
    col.name = "k10_NhCoord20_anno"
  )

table(CosMX_RNA_merged$k10_NhCoord20_anno)
#            Bcell_Plasma                     CAFs    DC_T_iCAF_Tumor_Mixed              Endothelial          Macrophage_High Myeloid_K17+_Tumor_Mixed               Tumor_High 
#                   22398                    15427                    23634                     5995                     9422                    14217                   133021 
#      Tumor_Immune_Mixed 
#                   25680 

save(CosMX_RNA_merged, file = 'CosMX_TMA/CosMX_RNA_merged.rda')
```

```{r S1A--CosMx protein cell type frequency}

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", 
                    "#FF7F00", "#FDB462", "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", 
                    "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", 
                    "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# adding protein neighborhoods to the CosMx protein data
load("CosMX_protein_annot_cluster.rda")

CosMx_Protein_log_norm$merged_annot_cluster <- factor(CosMx_Protein_log_norm$merged_annot_cluster, 
                            levels=c("Tumor_cells",
                                     "Fibroblasts/SMCs", 
                                     "Endothelial_cells", 
                                     "Plasma_cells", 
                                     "B_cells",
                                     "Tregs", 
                                     "CD8+T_cells", 
                                     "CD4+T_cells", 
                                     "NK_cells", 
                                     "Neutrophils", 
                                     "DCs", 
                                     "Macrophages", 
                                     "Monocytes"))
Idents(CosMx_Protein_log_norm) <- 'merged_annot_cluster'

# Step 1: Create a named vector for cluster order
cluster_order <- c(
  "Tumor_cells" = "1",
  "Fibroblasts/SMCs" = "2",
  "Endothelial_cells" = "3",
  "Plasma_cells" = "4",
  "B_cells" = "5",
  "Tregs" = "6",
  "CD8+T_cells" = "7",
  "CD4+T_cells" = "8",
  "NK_cells" = "9",
  "Neutrophils" = "10",
  "DCs" = "11",
  "Macrophages" = "12",
  "Monocytes" = "13"
)

# Step 2: Create a custom labeller function
custom_labeller <- function(variable, value) {
  return(names(cluster_order)[match(value, cluster_order)])
}


# plotting cell type frequency 
freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  SEU$orig.ident <- SEU[[c('Patient.ID')]]
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs),]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
    # Define the custom order for clusters
    cluster_order <- c(
      "Tumor_cells" = "Tumor_cells",
      "Fibroblasts/SMCs" = "Fibroblasts/SMCs",
      "Endothelial_cells" = "Endothelial_cells",
      "Plasma_cells" = "Plasma_cells",
      "B_cells" = "B_cells",
      "Tregs" = "Tregs",
      "CD8+T_cells" = "CD8+T_cells",
      "CD4+T_cells" = "CD4+T_cells",
      "NK_cells" = "NK_cells",
      "Neutrophils" = "Neutrophils",
      "DCs" = "DCs",
      "Macrophages" = "Macrophages",
      "Monocytes" = "Monocytes"
    )
    
    # Convert Cluster to factor with custom order
    #df$Cluster <- factor(df$Cluster, levels = names(cluster_order))
    
    ggplot(df) +
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), 
                   position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), 
                 alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 3, ncol = 5,
                 #labeller = as_labeller(cluster_order)
                 ) + 
      theme_bw() + 
      stat_compare_means(aes(x = Group, y = Freqs), label.y.npc = 0.85) +
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(), 
            axis.title.x = element_blank(), 
            strip.text = element_text(size = 12)) + 
      scale_shape_manual(values = 1:5) + 
      theme(legend.key.size = unit(1, 'cm'), 
            legend.title = element_text(size=30), 
            legend.text = element_text(size=20), 
            axis.text = element_text(size=16),
            axis.title = element_text(size=30), 
            legend.position = 'none') + 
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      labs(y = "Cell Type Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), 
           width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

test <- freq_plot(SEU = CosMx_Protein_log_norm, 
                  metadata = 'merged_annot_cluster', 
                  split.meta = 'Response', 
                  graph_type = 'freq_boxplot', 
                  out = 'CosMx_protein_', 
                  out_width = 10.5, 
                  out_height = 6, 
                  out_units = 'in', 
                  out_res = 300, 
                  test_by_group = TRUE)
```

```{r S1B -- CosMx protein recluster (leaving transferred clusters separately)}
load("CosMX_protein_annot_cluster.rda")
DimPlot(CosMx_Protein_log_norm, group.by = 'merged_annot_cluster', raster = F)

tumor_protein <- CosMx_Protein_log_norm[,grep('Tumor', CosMx_Protein_log_norm$merged_annot_cluster)]
tumor_protein <- FindClusters(tumor_protein, resolution = 0.01)

DimPlot(tumor_protein, group.by = 'Protein_snn_res.0.01', raster = F, label = T)

Idents(tumor_protein) <- 'Protein_snn_res.0.01'

#DotPlot(tumor_protein, features = c('FOXP3', 'CD3', 'CD15', 'CD31', 'CD56', 'GZMB', 'CD163', 'CD11b', 'EpCAM', 'panRAS', 'Beta-catenin'), col.min = 0)
#VlnPlot(tumor_protein, features = c('FOXP3', 'CD3', 'CD15', 'CD31', 'CD56', 'GZMB', 'CD163', 'CD11b', 'EpCAM', 'panRAS', 'Beta-catenin'), raster = F)



tregs <- colnames(tumor_protein)[grep('10|14', tumor_protein$Protein_snn_res.0.01)]
endo <- colnames(tumor_protein)[tumor_protein$Protein_snn_res.0.01 %in% c(6, 9, 19, 28)]
nk <- colnames(tumor_protein)[tumor_protein$Protein_snn_res.0.01 %in% c(15, 27)]
tcells <- colnames(tumor_protein)[tumor_protein$Protein_snn_res.0.01 %in% c(17, 21, 22, 23, 24)]
neut <- colnames(tumor_protein)[tumor_protein$Protein_snn_res.0.01 %in% c(4, 5, 7, 13, 16, 18)]
endo2 <- colnames(tumor_protein)[tumor_protein$Protein_snn_res.0.01 %in% c(3, 12, 11)]

CosMx_Protein_log_norm$merged_annot_cluster[colnames(CosMx_Protein_log_norm) %in% c(tregs)] <- 'Reannotated_Tregs'
CosMx_Protein_log_norm$merged_annot_cluster[colnames(CosMx_Protein_log_norm) %in% c(endo)] <- 'Reannotated_Endothelial_cells'
CosMx_Protein_log_norm$merged_annot_cluster[colnames(CosMx_Protein_log_norm) %in% c(nk)] <- 'Reannotated_NK_cells'
CosMx_Protein_log_norm$merged_annot_cluster[colnames(CosMx_Protein_log_norm) %in% c(tcells)] <- 'Reannotated_CD8Tcells'
CosMx_Protein_log_norm$merged_annot_cluster[colnames(CosMx_Protein_log_norm) %in% c(neut)] <- 'Reannotated_Neutrophils'
CosMx_Protein_log_norm$merged_annot_cluster[colnames(CosMx_Protein_log_norm) %in% c(endo2)] <- 'Reannotated_Endothelial_cells'

table(CosMx_Protein_log_norm$merged_annot_cluster)

#          B_cells       CD4+T_cells       CD8+T_cells               DCs Endothelial_cells  Fibroblasts/SMCs       Macrophages         Monocytes       Neutrophils          NK_cells 
#             9783              9344              7815              7339             15918             39678             15686              6058              4789               223 
#     Plasma_cells             Tregs       Tumor_cells 
#            12443              4340            139189 

CosMx_Protein_log_norm$merged_annot_cluster <- factor(CosMx_Protein_log_norm$merged_annot_cluster, 
                            levels=c("Tumor_cells",
                                     "Fibroblasts/SMCs", 
                                     "Endothelial_cells", 
                                     "Plasma_cells", 
                                     "B_cells",
                                     "Tregs", 
                                     'Tcells',
                                     "CD8+T_cells", 
                                     "CD4+T_cells", 
                                     "NK_cells", 
                                     "Neutrophils", 
                                     "DCs", 
                                     "Macrophages", 
                                     "Monocytes", 
                                     'Reannotated_Tregs', 
                                     'Reannotated_Endothelial_cells',
                                     'Reannotated_NK_cells',
                                     'Reannotated_CD8Tcells', 
                                     'Reannotated_Neutrophils',
                                     'Reannotated_Macrophages'))
Idents(CosMx_Protein_log_norm) <- 'merged_annot_cluster'

# pick out representative markers per cluster
features <- c('panRAS', 'EpCAM', 'Beta-catenin', 'SMA', 'VIM', 'CD31', 'FCN1', 'S100A8', 'S100A9', 'VCAN', 'CD14', 'CD16', 'CD163','CD68', 'HLA-DRA', 'CD11c', 'CCR7', 'CD15', 'CD11b',
              'CD56', 'GZMB', 'CD3', 'CD4', 'CD8', 'FOXP3', 'CTLA4', 'CD19', 'CD20', 'CD38', 'CD138')
DotPlot_aeg <- function (object, features, assay = NULL, cols = c("lightgrey", 
                                                                  "blue"), col.min = -2.5, col.max = 2.5, dot.min = 0, dot.scale = 6, 
                         idents = NULL, group.by = NULL, split.by = NULL, cluster.idents = FALSE, 
                         scale = TRUE, scale.by = "radius", scale.min = NA, scale.max = NA) 
{
  assay <- assay %||% DefaultAssay(object = object)
  DefaultAssay(object = object) <- assay
  split.colors <- !is.null(x = split.by) && !any(cols %in% 
                                                   rownames(x = brewer.pal.info))
  scale.func <- switch(EXPR = scale.by, size = scale_size, 
                       radius = scale_radius, stop("'scale.by' must be either 'size' or 'radius'"))
  feature.groups <- NULL
  if (is.list(features) | any(!is.na(names(features)))) {
    feature.groups <- unlist(x = sapply(X = 1:length(features), 
                                        FUN = function(x) {
                                          return(rep(x = names(x = features)[x], each = length(features[[x]])))
                                        }))
    if (any(is.na(x = feature.groups))) {
      warning("Some feature groups are unnamed.", call. = FALSE, 
              immediate. = TRUE)
    }
    features <- unlist(x = features)
    names(x = feature.groups) <- features
  }
  cells <- unlist(x = CellsByIdentities(object = object, cells = colnames(object[[assay]]), 
                                        idents = idents))
  data.features <- FetchData(object = object, vars = features, 
                             cells = cells)
  data.features$id <- if (is.null(x = group.by)) {
    Idents(object = object)[cells, drop = TRUE]
  }
  else {
    object[[group.by, drop = TRUE]][cells, drop = TRUE]
  }
  if (!is.factor(x = data.features$id)) {
    data.features$id <- factor(x = data.features$id)
  }
  id.levels <- levels(x = data.features$id)
  data.features$id <- as.vector(x = data.features$id)
  if (!is.null(x = split.by)) {
    splits <- FetchData(object = object, vars = split.by)[cells, 
                                                          split.by]
    if (split.colors) {
      if (length(x = unique(x = splits)) > length(x = cols)) {
        stop(paste0("Need to specify at least ", length(x = unique(x = splits)), 
                    " colors using the cols parameter"))
      }
      cols <- cols[1:length(x = unique(x = splits))]
      names(x = cols) <- unique(x = splits)
    }
    data.features$id <- paste(data.features$id, splits, 
                              sep = "_")
    unique.splits <- unique(x = splits)
    id.levels <- paste0(rep(x = id.levels, each = length(x = unique.splits)), 
                        "_", rep(x = unique(x = splits), times = length(x = id.levels)))
  }
  data.plot <- lapply(X = unique(x = data.features$id), FUN = function(ident) {
    data.use <- data.features[data.features$id == ident, 
                              1:(ncol(x = data.features) - 1), drop = FALSE]
    avg.exp <- apply(X = data.use, MARGIN = 2, FUN = function(x) {
      return(mean(x = expm1(x = x)))
    })
    pct.exp <- apply(X = data.use, MARGIN = 2, FUN = PercentAbove, 
                     threshold = 0)
    return(list(avg.exp = avg.exp, pct.exp = pct.exp))
  })
  names(x = data.plot) <- unique(x = data.features$id)
  if (cluster.idents) {
    mat <- do.call(what = rbind, args = lapply(X = data.plot, 
                                               FUN = unlist))
    mat <- scale(x = mat)
    id.levels <- id.levels[hclust(d = dist(x = mat))$order]
  }
  data.plot <- lapply(X = names(x = data.plot), FUN = function(x) {
    data.use <- as.data.frame(x = data.plot[[x]])
    data.use$features.plot <- rownames(x = data.use)
    data.use$id <- x
    return(data.use)
  })
  data.plot <- do.call(what = "rbind", args = data.plot)
  if (!is.null(x = id.levels)) {
    data.plot$id <- factor(x = data.plot$id, levels = id.levels)
  }
  ngroup <- length(x = levels(x = data.plot$id))
  if (ngroup == 1) {
    scale <- FALSE
    warning("Only one identity present, the expression values will be not scaled", 
            call. = FALSE, immediate. = TRUE)
  }
  else if (ngroup < 5 & scale) {
    warning("Scaling data with a low number of groups may produce misleading results", 
            call. = FALSE, immediate. = TRUE)
  }
  avg.exp.scaled <- sapply(X = unique(x = data.plot$features.plot), 
                           FUN = function(x) {
                             data.use <- data.plot[data.plot$features.plot == 
                                                     x, "avg.exp"]
                             if (scale) {
                               data.use <- scale(x = log1p(data.use))
                               data.use <- MinMax(data = data.use, min = col.min, 
                                                  max = col.max)
                             }
                             else {
                               data.use <- log1p(x = data.use)
                             }
                             return(data.use)
                           })
  avg.exp.scaled <- as.vector(x = t(x = avg.exp.scaled))
  if (split.colors) {
    avg.exp.scaled <- as.numeric(x = cut(x = avg.exp.scaled, 
                                         breaks = 20))
  }
  data.plot$avg.exp.scaled <- avg.exp.scaled
  data.plot$features.plot <- factor(x = data.plot$features.plot, 
                                    levels = features)
  data.plot$pct.exp[data.plot$pct.exp < dot.min] <- NA
  data.plot$pct.exp <- data.plot$pct.exp * 100
  if (split.colors) {
    splits.use <- unlist(x = lapply(X = data.plot$id, FUN = function(x) sub(paste0(".*_(", 
                                                                                   paste(sort(unique(x = splits), decreasing = TRUE), 
                                                                                         collapse = "|"), ")$"), "\\1", x)))
    data.plot$colors <- mapply(FUN = function(color, value) {
      return(colorRampPalette(colors = c("grey", color))(20)[value])
    }, color = cols[splits.use], value = avg.exp.scaled)
  }
  color.by <- ifelse(test = split.colors, yes = "colors", 
                     no = "avg.exp.scaled")
  if (!is.na(x = scale.min)) {
    data.plot[data.plot$pct.exp < scale.min, "pct.exp"] <- scale.min
  }
  if (!is.na(x = scale.max)) {
    data.plot[data.plot$pct.exp > scale.max, "pct.exp"] <- scale.max
  }
  if (!is.null(x = feature.groups)) {
    data.plot$feature.groups <- factor(x = feature.groups[data.plot$features.plot], 
                                       levels = unique(x = feature.groups))
  }
  plot <- ggplot(data = data.plot, mapping = aes_string(x = "features.plot", 
                                                        y = "id")) + geom_point(mapping = aes_string(size = "pct.exp", 
                                                                                                     color = color.by)) + scale.func(range = c(0, dot.scale), 
                                                                                                                                     limits = c(scale.min, scale.max)) + theme(axis.title.x = element_blank(), 
                                                                                                                                                                               axis.title.y = element_blank()) + guides(size = guide_legend(title = "% Exp")) + 
    labs(x = "", y = ifelse(test = is.null(x = split.by), 
                            yes = "", no = "Split Identity")) + theme_cowplot()
  if (!is.null(x = feature.groups)) {
    plot <- plot + facet_grid(facets = ~feature.groups, 
                              scales = "free_x", space = "free_x", switch = "y") + 
      theme(panel.spacing = unit(x = 1, units = "lines"), 
            strip.background = element_blank())
  }
  if (split.colors) {
    plot <- plot + scale_color_identity()
  }
  else if (length(x = cols) == 1) {
    plot <- plot + scale_color_distiller(palette = cols)
  }
  else {
    plot <- plot + scale_color_gradient(low = cols[1], high = cols[2])
  }
  if (!split.colors) {
    plot <- plot + guides(color = guide_colorbar(title = "Avg Exp"))
  }
  return(plot)
}

DotPlot_aeg(object = CosMx_Protein_log_norm, 
            group.by = 'merged_annot_cluster', 
            features = features, 
            col.min = 0, 
            cols = c('lightgray', 'red')) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + coord_flip()
ggsave('S1B_CosMx_Protein_DE_genes.pdf', width = 6, height = 8)

CosMx_Protein_log_norm$merged_annot_cluster[CosMx_Protein_log_norm$merged_annot_cluster == 'Reannotated_Tregs'] <- 'Tregs'
CosMx_Protein_log_norm$merged_annot_cluster[CosMx_Protein_log_norm$merged_annot_cluster == 'Reannotated_Endothelial_cells'] <- 'Endothelial_cells'
CosMx_Protein_log_norm$merged_annot_cluster[CosMx_Protein_log_norm$merged_annot_cluster == 'Reannotated_NK_cells'] <- 'NK_cells'
CosMx_Protein_log_norm$merged_annot_cluster[CosMx_Protein_log_norm$merged_annot_cluster == 'Reannotated_CD8Tcells'] <- 'CD8+T_cells'
CosMx_Protein_log_norm$merged_annot_cluster[CosMx_Protein_log_norm$merged_annot_cluster == 'Reannotated_Neutrophils'] <- 'Neutrophils'

DotPlot_aeg(object = CosMx_Protein_log_norm, 
            group.by = 'merged_annot_cluster', 
            features = features, 
            col.min = 0, 
            cols = c('lightgray', 'red')) +
  theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust=1)) 

ggsave('../Figure1/CosMx_Protein_DE_genes.pdf', width = 8, height = 5)
```

```{r S1C--CosMx RNA KRT genes Dotplot}
# plotting the keratin genes in the RNA data
load('CosMX_TMA/CosMX_RNA_merged.rda')

DotPlot(CosMX_RNA_merged[,CosMX_RNA_merged$annot_cluster2 %in% c('Tumors_Others', 'Tumors_KRT19+',
                                                                 'Tumors_KRT17+', 'Tumors_HIF1A+')], 
        features = grep('^KRT', rownames(CosMX_RNA_merged), value = T), 
        group.by = 'annot_cluster2', col.min = 0) + 
  #coord_flip() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggsave('CosMx_RNA_KRT_genes_dotplot.pdf', width = 7, height = 4)
```

```{r S1D--CosMx RNA CAF dotplot/heatmap}
# plotting the keratin genes in the RNA data
load('CosMX_TMA/CosMX_RNA_merged.rda')

hla <- grep('HLA', rownames(CosMX_RNA_merged), value = T)

dp <- DotPlot(CosMX_RNA_merged[, grep('CAF', CosMX_RNA_merged$annot_cluster2)], 
        features = c(hla, 'CD74'), 
        group.by = 'annot_cluster2', col.min = 0) + 
  #coord_flip() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

library(tidyverse)
library(ComplexHeatmap)

# Your original code
data <- as.data.frame(dp$data) %>% select(c('avg.exp', 'id', 'features.plot'))
data2 <- data %>% pivot_wider(names_from = 'id', values_from = 'avg.exp') %>% 
  tibble::column_to_rownames('features.plot')

# Convert to matrix (if not already a matrix)
data_mat <- as.matrix(data2)

# Z-score normalize by row (mean center and scale by row)
z_data <- t(scale(t(data_mat)))

# Plot with ComplexHeatmap
ComplexHeatmap::Heatmap(z_data)


ggsave('CosMx_RNA_CAF_genes_dotplot.pdf', width = 8, height = 4)
```

```{r S1D--CosMx RNA cell type frequency}
load('CosMX_RNA_merged.rda')

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", 
                    "#FF7F00", "#FDB462", "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", 
                    "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", 
                    "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

CosMX_RNA_merged$annot_cluster2[grep('inflammatory', CosMX_RNA_merged$annot_cluster2)] <- 'Fibroblast_VEGFA_iCAFs'
CosMX_RNA_merged$annot_cluster2 <- gsub("Fibroblast", "Fib", CosMX_RNA_merged$annot_cluster2)


freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  SEU$orig.ident <- SEU[[c('PatientID')]]
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs),]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
    # Define the custom order for clusters
    cluster_order <- c(
      "Tumors_HIF1A+" = "Tumors_HIF1A+",
      "Tumors_KRT17+" = "Tumors_KRT17+",
      "Tumors_KRT19+" = "Tumors_KRT19+",
      "Tumors_Others" = "Tumors_Others",
      "Fib_apCAFs" = "Fib_apCAFs",
      "Fib_myCAFs" = "Fib_myCAFs",
      "Fib_VEGFA_iCAFs" = "Fib_VEGFA_iCAFs",
      "Endothelials" = "Endothelials",
      "Bcells" = "Bcells",
      "Plasma" = "Plasma",
      "Tcells_CD4+" = "Tcells_CD4+",
      "TcellsCD8+" = "TcellsCD8+",
      "Tregs" = "Tregs",
      'DCs' = 'DCs',
      'Macrophages' = 'Macrophages',
      'Monocytes' = 'Monocytes'
    )
    
    # Convert Cluster to factor with custom order
    df$Cluster <- factor(df$Cluster, levels = names(cluster_order))
    
    ggplot(df) +
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), 
                   position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), 
                 alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 3, ncol = 6,
                 labeller = as_labeller(cluster_order)) + 
      theme_bw() + 
      stat_compare_means(aes(x = Group, y = Freqs), label.y.npc = 0.85) +
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(), 
            axis.title.x = element_blank(), 
            strip.text = element_text(size = 12)) + 
      scale_shape_manual(values = 1:5) + 
      theme(legend.key.size = unit(1, 'cm'), 
            legend.title = element_text(size=30), 
            legend.text = element_text(size=20), 
            axis.text = element_text(size=16),
            axis.title = element_text(size=30), 
            legend.position = 'none') + 
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      labs(y = "Cell Type Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), 
           width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

test <- freq_plot(SEU = CosMX_RNA_merged, 
                  metadata = 'annot_cluster2', 
                  split.meta = 'Response', 
                  graph_type = 'freq_boxplot', 
                  out = 'CosMx_RNA_', 
                  out_width = 12.5, 
                  out_height = 7, 
                  out_units = 'in', 
                  out_res = 300, 
                  test_by_group = TRUE)
```

```{r S1E--CosMx protein/RNA cell type freq correlation WITH TUMOR CELLs}
load("CosMX_TMA/CosMX_RNA_merged.rda")
load("CosMX_TMA/Protein-data/Analysis/CosMX_protein_annot_cluster.rda")

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3", "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

meta_rna <- as.data.frame(table(CosMX_RNA_merged$annot_cluster2, CosMX_RNA_merged$tma_fov_id))
meta_protein <- as.data.frame(table(CosMx_Protein_log_norm$merged_annot_cluster, CosMx_Protein_log_norm$tma_fov_id))

# calculate percentages by FOV for the RNA FOVs
# Step 2: Group by sample (Var2) and calculate percentages
meta_rna_percentages <- meta_rna %>%
  group_by(Var2) %>%
  mutate(Percentage = Freq / sum(Freq) * 100) %>%
  ungroup()
# Step 3: Round the percentages to two decimal places (optional)
meta_rna_percentages$Percentage <- round(meta_rna_percentages$Percentage, 2)
# Step 4: View the first few rows of the new dataframe
head(meta_rna_percentages)
# Sanity check
sanity_check <- meta_rna_percentages %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
# View the results
print(sanity_check)
# Check if all samples sum to approximately 100%
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
# If not all correct, view the problematic samples
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}






# calculate percentages by FOV for the protein FOVs
# Step 2: Group by sample (Var2) and calculate percentages
meta_protein_percentages <- meta_protein %>%
  group_by(Var2) %>%
  mutate(Percentage = Freq / sum(Freq) * 100) %>%
  ungroup()
# Step 3: Round the percentages to two decimal places (optional)
meta_protein_percentages$Percentage <- round(meta_protein_percentages$Percentage, 2)
# Step 4: View the first few rows of the new dataframe
head(meta_protein_percentages)
# Sanity check
sanity_check <- meta_protein_percentages %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
# View the results
print(sanity_check)
# Check if all samples sum to approximately 100%
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
# If not all correct, view the problematic samples
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}




unique(meta_rna_percentages$Var1)
# [1] Bcells                                 DCs                                    Endothelials                           Fibroblast_apCAFs                     
# [5] Fibroblast_myCAFs                      Fibroblast_VEGFA_inflammatorylike_CAFs Macrophages                            Monocytes                             
# [9] Plasma                                 Tcells_CD4+                            TcellsCD8+                             Tregs                                 
# [13] Tumors_HIF1A+                          Tumors_KRT17+                          Tumors_KRT19+                          Tumors_Others 
unique(meta_protein_percentages$Var1)
# [1] B_cells           CD4+T_cells       CD8+T_cells       DCs               Endothelial_cells Fibroblasts/SMCs  Macrophages       Monocytes         Neutrophils       NK_cells         
# [11] Plasma_cells      Tregs             Tumor_cells     





library(stringr)

# Create a new column for the broader categories
meta_rna_aggregated <- meta_rna_percentages %>%
  mutate(
    Broad_Category = case_when(
      str_starts(Var1, "Tumors") ~ "Tumor_cells",
      str_starts(Var1, "Fibroblast") ~ "Fibroblasts/SMCs",
      TRUE ~ as.character(Var1)  # Keep other categories as they are
    )
  )
# Aggregate the percentages for the broader categories
meta_rna_aggregated <- meta_rna_aggregated %>%
  group_by(Var2, Broad_Category) %>%
  summarize(
    Aggregated_Percentage = sum(Percentage),
    .groups = "drop"
  ) %>%
  rename(Var1 = Broad_Category)
# Round the aggregated percentages to two decimal places
meta_rna_aggregated$Aggregated_Percentage <- round(meta_rna_aggregated$Aggregated_Percentage, 2)
# View the first few rows of the new dataframe
head(meta_rna_aggregated)
# Perform a sanity check on the aggregated data
sanity_check <- meta_rna_aggregated %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Aggregated_Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
print(sanity_check)
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}







meta_rna_aggregated <- meta_rna_aggregated %>%
  mutate(Var1 = case_when(
    Var1 == "Bcells" ~ "B_cells",
    Var1 == "Endothelials" ~ "Endothelial_cells",
    Var1 == "Plasma" ~ "Plasma_cells",
    Var1 == "Tcells_CD4+" ~ "CD4+T_cells",
    Var1 == "TcellsCD8+" ~ "CD8+T_cells",
    TRUE ~ as.character(Var1)  # Keep other categories as they are
  ))
# View the first few rows to check the changes
head(meta_rna_aggregated)
# Optional: Check unique values in Var1 to ensure all changes were made
unique(meta_rna_aggregated$Var1)
# look at the overlap between the dataset labels
intersect(meta_rna_aggregated$Var1, meta_protein_percentages$Var1)
# remove cell types not present in both groups so it is equal
meta_protein_percentages_mini <- meta_protein_percentages[grep('NK_cells|Neutrophils', meta_protein_percentages$Var1, invert = T), c('Var1', 'Var2', 'Percentage')]
# making a "group" column to merge by
meta_rna_aggregated$group <- paste(meta_rna_aggregated$Var1, meta_rna_aggregated$Var2, sep = ':')
meta_protein_percentages_mini$group <- paste(meta_protein_percentages_mini$Var1, meta_protein_percentages_mini$Var2, sep = ':')
# merge both RNa and protein data together
all_data <- merge(meta_rna_aggregated, meta_protein_percentages_mini, by = 'group')






ggplot(all_data, aes(x=Aggregated_Percentage, y=Percentage, color = Var1.x)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "grey", linetype = "dashed") +
  stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
               formula = y ~ x, parse = TRUE, color = "black") +
  theme_classic() + 
  xlab('Cell Type Percentage by FOV in CosMx RNA data') + 
  ylab('Cell Type Percentage by FOV in CosMx Protein data') +
  scale_color_manual(values = color_clusters) +
  labs(color = "Cell Type") +
  ggtitle('Cell type frequency per FOV by dataset') +
  theme(
    axis.title = element_text(size = 16, face = "bold"),  # Larger axis labels
    axis.text = element_text(size = 14),  # Larger axis text
    legend.title = element_text(size = 14, face = "bold"),  # Larger legend title
    legend.text = element_text(size = 12),  # Larger legend text
    legend.key.size = unit(1, "cm"),  # Larger legend keys
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)  # Larger, centered title
  )

ggsave('cosmx_celltypecomparison_scatterplot.pdf', dpi = 900, width = 9, height = 6)

```

```{r S1E--CosMx protein/RNA cell type freq correlation WITHout TUMOR CELLs}
load("CosMX_RNA_merged.rda")
load("Protein-data/Analysis/CosMX_protein_annot_cluster.rda")

CosMX_RNA_merged <- CosMX_RNA_merged[,grep('Tumor', CosMX_RNA_merged$annot_cluster2, invert = T)]
CosMx_Protein_log_norm <- CosMx_Protein_log_norm[,grep('Tumor', CosMx_Protein_log_norm$merged_annot_cluster, invert = T)]

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3", "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

meta_rna <- as.data.frame(table(CosMX_RNA_merged$annot_cluster2, CosMX_RNA_merged$tma_fov_id))
meta_protein <- as.data.frame(table(CosMx_Protein_log_norm$merged_annot_cluster, CosMx_Protein_log_norm$tma_fov_id))

# calculate percentages by FOV for the RNA FOVs
# Step 2: Group by sample (Var2) and calculate percentages
meta_rna_percentages <- meta_rna %>%
  group_by(Var2) %>%
  mutate(Percentage = Freq / sum(Freq) * 100) %>%
  ungroup()
# Step 3: Round the percentages to two decimal places (optional)
meta_rna_percentages$Percentage <- round(meta_rna_percentages$Percentage, 2)
# Step 4: View the first few rows of the new dataframe
head(meta_rna_percentages)
# Sanity check
sanity_check <- meta_rna_percentages %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
# View the results
print(sanity_check)
# Check if all samples sum to approximately 100%
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
# If not all correct, view the problematic samples
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}






# calculate percentages by FOV for the protein FOVs
# Step 2: Group by sample (Var2) and calculate percentages
meta_protein_percentages <- meta_protein %>%
  group_by(Var2) %>%
  mutate(Percentage = Freq / sum(Freq) * 100) %>%
  ungroup()
# Step 3: Round the percentages to two decimal places (optional)
meta_protein_percentages$Percentage <- round(meta_protein_percentages$Percentage, 2)
# Step 4: View the first few rows of the new dataframe
head(meta_protein_percentages)
# Sanity check
sanity_check <- meta_protein_percentages %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
# View the results
print(sanity_check)
# Check if all samples sum to approximately 100%
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
# If not all correct, view the problematic samples
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}




unique(meta_rna_percentages$Var1)
# [1] Bcells                                 DCs                                    Endothelials                           Fibroblast_apCAFs                     
# [5] Fibroblast_myCAFs                      Fibroblast_VEGFA_inflammatorylike_CAFs Macrophages                            Monocytes                             
# [9] Plasma                                 Tcells_CD4+                            TcellsCD8+                             Tregs                                 
# [13] Tumors_HIF1A+                          Tumors_KRT17+                          Tumors_KRT19+                          Tumors_Others 
unique(meta_protein_percentages$Var1)
# [1] B_cells           CD4+T_cells       CD8+T_cells       DCs               Endothelial_cells Fibroblasts/SMCs  Macrophages       Monocytes         Neutrophils       NK_cells         
# [11] Plasma_cells      Tregs             Tumor_cells     





library(stringr)

# Create a new column for the broader categories
meta_rna_aggregated <- meta_rna_percentages %>%
  mutate(
    Broad_Category = case_when(
      str_starts(Var1, "Tumors") ~ "Tumor_cells",
      str_starts(Var1, "Fibroblast") ~ "Fibroblasts/SMCs",
      TRUE ~ as.character(Var1)  # Keep other categories as they are
    )
  )
# Aggregate the percentages for the broader categories
meta_rna_aggregated <- meta_rna_aggregated %>%
  group_by(Var2, Broad_Category) %>%
  summarize(
    Aggregated_Percentage = sum(Percentage),
    .groups = "drop"
  ) %>%
  rename(Var1 = Broad_Category)
# Round the aggregated percentages to two decimal places
meta_rna_aggregated$Aggregated_Percentage <- round(meta_rna_aggregated$Aggregated_Percentage, 2)
# View the first few rows of the new dataframe
head(meta_rna_aggregated)
# Perform a sanity check on the aggregated data
sanity_check <- meta_rna_aggregated %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Aggregated_Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
print(sanity_check)
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}







meta_rna_aggregated <- meta_rna_aggregated %>%
  mutate(Var1 = case_when(
    Var1 == "Bcells" ~ "B_cells",
    Var1 == "Endothelials" ~ "Endothelial_cells",
    Var1 == "Plasma" ~ "Plasma_cells",
    Var1 == "Tcells_CD4+" ~ "CD4+T_cells",
    Var1 == "TcellsCD8+" ~ "CD8+T_cells",
    TRUE ~ as.character(Var1)  # Keep other categories as they are
  ))
# View the first few rows to check the changes
head(meta_rna_aggregated)
# Optional: Check unique values in Var1 to ensure all changes were made
unique(meta_rna_aggregated$Var1)
# look at the overlap between the dataset labels
intersect(meta_rna_aggregated$Var1, meta_protein_percentages$Var1)
# remove cell types not present in both groups so it is equal
meta_protein_percentages_mini <- meta_protein_percentages[grep('NK_cells|Neutrophils', meta_protein_percentages$Var1, invert = T), c('Var1', 'Var2', 'Percentage')]
# making a "group" column to merge by
meta_rna_aggregated$group <- paste(meta_rna_aggregated$Var1, meta_rna_aggregated$Var2, sep = ':')
meta_protein_percentages_mini$group <- paste(meta_protein_percentages_mini$Var1, meta_protein_percentages_mini$Var2, sep = ':')
# merge both RNa and protein data together
all_data <- merge(meta_rna_aggregated, meta_protein_percentages_mini, by = 'group')






ggplot(all_data, aes(x=Aggregated_Percentage, y=Percentage, color = Var1.x)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "grey", linetype = "dashed") +
  stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
               formula = y ~ x, parse = TRUE, color = "black") +
  theme_classic() + 
  xlab('Cell Type Percentage by FOV in CosMx RNA data') + 
  ylab('Cell Type Percentage by FOV in CosMx Protein data') +
  scale_color_manual(values = color_clusters) +
  labs(color = "Cell Type") +
  ggtitle('Cell type frequency per FOV by dataset') +
  theme(
    axis.title = element_text(size = 16, face = "bold"),  # Larger axis labels
    axis.text = element_text(size = 14),  # Larger axis text
    legend.title = element_text(size = 14, face = "bold"),  # Larger legend title
    legend.text = element_text(size = 12),  # Larger legend text
    legend.key.size = unit(1, "cm"),  # Larger legend keys
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)  # Larger, centered title
  )

ggsave('NOTUMORS_cosmx_celltypecomparison_scatterplot.pdf', dpi = 900, width = 9, height = 6)

```

```{r S1F--SCDC Broad cell type boxplot from Visium}
scdc <- read.csv('HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/SCDC_compartment_proportions.csv') %>% 
  select(c(Cell_Type, Proportion, Sample_Name, Response))

scdc <- scdc %>%
  group_by(Cell_Type, Sample_Name) %>%
  summarise(Proportion = mean(Proportion),
            Response = first(Response),
            .groups = "drop")

# First, calculate the sum of proportions for each Sample_Name
sample_totals <- scdc %>%
  group_by(Sample_Name) %>%
  summarise(Total = sum(Proportion))

# Create the "Others" category
others <- scdc %>%
  group_by(Sample_Name) %>%
  summarise(
    Cell_Type = "Others",
    Proportion = 1 - sum(Proportion),
    Response = first(Response)
  )

# Combine the original data with the "Others" category
scdc_with_others <- bind_rows(scdc, others)

# Reorder the rows to group by Sample_Name
scdc_with_others <- scdc_with_others %>%
  arrange(Sample_Name, Cell_Type)

# plotting
g1 <- ggplot(scdc_with_others[!scdc_with_others$Sample_Name %in% c('ck17_209', 'ck17_21', 'ck17_27'),], aes(x = Response, y = Proportion, color = Response, fill = Response)) + 
  geom_boxplot(aes(x = Response, y = Proportion, color = Response, fill = Response), position = position_dodge(), alpha = 0.5, 
               outlier.color = NA) + 
  geom_point(aes(x = Response, y = Proportion, color = Response), alpha = 0.8, position = position_jitterdodge()) + 
  theme_bw() + 
  facet_grid(~Cell_Type) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), 
        strip.text = element_text(size = 12)) + 
  scale_color_manual(values= c('#2196F3', '#FF8A80')) +
  scale_fill_manual(values = c('#2196F3', '#FF8A80')) +
  ylab('Estimated cell type freq') +
  stat_compare_means() +
  theme(legend.key.size = unit(1, 'cm'), legend.title = element_text(size=30), legend.text = element_text(size=20),
        axis.text=element_text(size=16),axis.title=element_text(size=20), legend.position = 'none')

pdf('SCDC_boxplots.pdf', pointsize = 14, width = 8, height = 4)
g1
dev.off()

 
```

```{r S1G--Luoma frequency boxplot}
library(Seurat)
library(ggplot2)
library(dplyr)
library(DescTools)

load('HNC_ICB_GolfinosOwens_etal_2025/objects/bill_luoma_consensus.rda')

luoma$consensus_clusters[luoma$consensus_clusters == c('Blood-like_CD14_Mono')] <- 'PBMC-like_CD14_Monocytes'

luoma@meta.data <- luoma@meta.data %>% mutate(consensus_clusters = case_when(consensus_clusters == c('Blood-like_CD14_Monoc') ~ 'PBMC-like_CD14_Monocytes'))

freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  SEU$orig.ident <- SEU[[c('Patient_ID')]]
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs),]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
  
    
    ggplot(df) +
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), 
                   position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), 
                 alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 4, ncol = 6,
                 #labeller = as_labeller(cluster_order)
      ) + 
      theme_bw() + 
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(), 
            axis.title.x = element_blank(), 
            strip.text = element_text(size = 12)) + 
      scale_shape_manual(values = 1:5) + 
      theme(legend.key.size = unit(1, 'cm'), 
            legend.title = element_text(size=30), 
            legend.text = element_text(size=20), 
            axis.text = element_text(size=16),
            axis.title = element_text(size=30), 
            legend.position = 'none') + 
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      labs(y = "Cell Type Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), 
           width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

test <- freq_plot(SEU = luoma, 
                  metadata = 'consensus_clusters', 
                  split.meta = 'response_binary', 
                  graph_type = 'freq_boxplot', 
                  out = 'luoma_', 
                  out_width = 18, 
                  out_height = 8, 
                  out_units = 'in', 
                  out_res = 300, 
                  test_by_group = TRUE)
```

```{r S1H--scGOclust myeloid cells Cillo Luoma}
# comparing Cillo object and our gene sigs with Luoma object and our gene sigs
library(Seurat)
library(pheatmap)
library(httr)
library(scGOclust)
library(ComplexHeatmap)
library(tibble)
library(dplyr)

# load in seurat objects
load('/HNC_ICB_GolfinosOwens_etal_2025/objects/bill_luoma_consensus.rda')
load('Seurat_Objs/HNC_human/cillo_all_cells.rda') # called hnc2


# confiiguring ensembl due to expired certificates
httr::set_config(httr::config(ssl_verifypeer = FALSE)) 
hs_tbl = ensemblToGo(species = 'hsapiens', GO_linkage_type = c('experimental', 'phylogenetic', 'computational', 'author', 'curator')) # get biological process GO terms
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())


# generating mini objects with just myeloid cells
luoma_mini <- luoma[,grep('DC|Mono|Mac', luoma$consensus_clusters)]
cillo_mini <- hnc2[,grep('DC|Mono|Mac', hnc2$global.cluster4)]
cillo_mini <- cillo_mini[,grep('TIL', cillo_mini$tissue)]

# getting metadata for luoma and Cillo myeloid cells
luoma_meta <- luoma_mini[[c('consensus_clusters', 'subset_CellType_ID', 'nCount_RNA', 'nFeature_RNA', 'response_binary')]]
cillo_meta <- cillo_mini[[c('global.cluster4', 'nCount_RNA', 'nFeature_RNA')]]

# creating the gene ontology seurat objects
luoma_go_obj <- makeGOSeurat(ensembl_to_GO = hs_tbl, feature_type = 'external_gene_name', seurat_obj = luoma_mini)
cillo_go_obj <- makeGOSeurat(ensembl_to_GO = hs_tbl, feature_type = 'external_gene_name', seurat_obj = cillo_mini)

# provide the cell type metadata so we can compare the labels
luoma_ct_go <- getCellTypeGO(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters')
cillo_ct_go <- getCellTypeGO(go_seurat_obj = cillo_go_obj, cell_type_col = 'global.cluster4')

# heatmap of Pearson's correlation coefficient of cell type average BP profiles within species
luoma_corr1 = cellTypeGOCorr(cell_type_go = luoma_ct_go, corr_method = 'pearson')
pheatmap(luoma_corr1)
cillo_corr1 = cellTypeGOCorr(cell_type_go = cillo_ct_go, corr_method = 'pearson')
pheatmap(cillo_corr1)

# analyze the cell-by-GO BP profile as a count matrix
luoma_go_analyzed = analyzeGOSeurat(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters', min.dist = 0.3, spread = 0.5)
cillo_go_analyzed = analyzeGOSeurat(go_seurat_obj = cillo_go_obj, cell_type_col = 'global.cluster4', min.dist = 0.3, spread = 0.5)


## calculation takes a few minutes due to the Wilcox signed rank test
ct_shared_go = scGOclust::getCellTypeSharedGO(species_1 = 'hsapiens', species_2 = 'hsapiens', analyzed_go_seurat_sp1 = luoma_go_analyzed, 
                                              analyzed_go_seurat_sp2 = cillo_go_analyzed, cell_type_col_sp1 = 'consensus_clusters', 
                                              cell_type_col_sp2 = 'global.cluster4', layer_use = 'data')
head(ct_shared_go$shared_sig_markers)

corr = crossSpeciesCellTypeGOCorr(species_1 = 'hsapiens', species_2 = 'hsapiens', cell_type_go_sp1 = luoma_ct_go, cell_type_go_sp2 = cillo_ct_go, corr_method = 'pearson')

rownames(corr) <- sapply(strsplit(rownames(corr),"_"), `[`, 2)
colnames(corr) <- sapply(strsplit(colnames(corr), '_'), `[`, 2)


pdf('CILLO_TUMOR_ONLY_myeloid_scGoclust_correlation_heatmap.pdf', width = 7, height = 6)
ComplexHeatmap::Heatmap(corr, border_gp = gpar(col = "black", lty = 1), column_title = 'Cillo et al (tumor only) myeloid cell subsets', 
                        column_title_side = 'bottom', row_title = 'Luoma et al myeloid cell subsets', 
                        row_title_side = 'right',  
                        cluster_columns = T, 
                        cluster_rows = T, 
                        heatmap_legend_param = list(
                          title = "Pearson correlation", title_position = 'leftcenter-rot'))
dev.off()
```

```{r S1I--scGOclust T cells Cillo Luoma}
# luoma-Cillo myeloid cell subtype comparison
library(Seurat)
library(pheatmap)
library(httr)
library(scGOclust)
library(ComplexHeatmap)
library(tibble)
library(dplyr)

# load in seurat objects
load('/HNC_ICB_GolfinosOwens_etal_2025/objects/bill_luoma_consensus.rda')

# confiiguring ensembl due to expired certificates
httr::set_config(httr::config(ssl_verifypeer = FALSE)) 
hs_tbl = ensemblToGo(species = 'hsapiens', GO_linkage_type = c('experimental', 'phylogenetic', 'computational', 'author', 'curator')) # get biological process GO terms
setwd('/HNC_ICB_GolfinosOwens_etal_2025/scGOclust/cillo_luoma_consensus_clusters/')

# generating mini objects with just myeloid cells
luoma_mini <- luoma[,grep('CD4|CD8|Treg|Tcells', luoma$consensus_clusters)]

# getting metadata for luoma and luoma T cells
luoma_meta <- luoma_mini[[c('consensus_clusters', 'subset_CellType_ID', 'nCount_RNA', 'nFeature_RNA', 'response_binary')]]

# creating the gene ontology seurat objects
luoma_go_obj <- makeGOSeurat(ensembl_to_GO = hs_tbl, feature_type = 'external_gene_name', seurat_obj = luoma_mini)

# provide the cell type metadata so we can compare the labels
luoma_ct_go_cillo <- getCellTypeGO(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters')
luoma_ct_go_luoma <- getCellTypeGO(go_seurat_obj = luoma_go_obj, cell_type_col = 'subset_CellType_ID')

# heatmap of Pearson's correlation coefficient of cell type average BP profiles within species
luoma_corr1 = cellTypeGOCorr(cell_type_go = luoma_ct_go_cillo, corr_method = 'pearson')
pheatmap(luoma_corr1)
luoma_corr2 = cellTypeGOCorr(cell_type_go = luoma_ct_go_luoma, corr_method = 'pearson')
pheatmap(luoma_corr2)

# analyze the cell-by-GO BP profile as a count matrix
luoma_go_analyzed_cillo = analyzeGOSeurat(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters', min.dist = 0.3, spread = 0.5)
luoma_go_analyzed_luoma = analyzeGOSeurat(go_seurat_obj = luoma_go_obj, cell_type_col = 'subset_CellType_ID', min.dist = 0.3, spread = 0.5)

# UMAP plot of the analyzed cell-by-GO BP profile, labeled by previously specified cell annotation column in meta.data
DimPlot(luoma_go_analyzed_cillo, label = TRUE) + NoLegend()
DimPlot(luoma_go_analyzed_luoma, label = TRUE) + NoLegend()

## calculation takes a few minutes due to the Wilcox signed rank test
ct_shared_go = scGOclust::getCellTypeSharedGO(species_1 = 'hsapiens', species_2 = 'hsapiens', analyzed_go_seurat_sp1 = luoma_go_analyzed_cillo, 
                                              analyzed_go_seurat_sp2 = luoma_go_analyzed_luoma, cell_type_col_sp1 = 'consensus_clusters', 
                                              cell_type_col_sp2 = 'subset_CellType_ID', layer_use = 'data')
head(ct_shared_go$shared_sig_markers)

corr = crossSpeciesCellTypeGOCorr(species_1 = 'hsapiens', species_2 = 'hsapiens', cell_type_go_sp1 = luoma_ct_go_cillo, cell_type_go_sp2 = luoma_ct_go_luoma, corr_method = 'pearson')

rownames(corr) <- sapply(strsplit(rownames(corr),"_"), `[`, 2)
colnames(corr) <- sapply(strsplit(colnames(corr), '_'), `[`, 2)

pdf('tcells_scGoclust_correlation_heatmap.pdf', width = 7, height = 6)
ComplexHeatmap::Heatmap(corr, border_gp = gpar(col = "black", lty = 1), column_title = 'Luoma et al T cell annotations', 
                        column_title_side = 'bottom', row_title = 'Cillo et al (reanalyzed) T cell annotations', 
                        row_title_side = 'right',  
                        cluster_columns = T, 
                        cluster_rows = T, 
                        heatmap_legend_param = list(
                          title = "Pearson correlation", title_position = 'leftcenter-rot'))
dev.off()
```

```{r S2A--protein neighborhood heatmap (20 clusters)}
load("CosMX_TMA/Protein-data/Analysis/CosMX_protein_annot_cluster.rda")

# Create a table of cell counts
cell_counts <- CosMx_Protein_log_norm@meta.data %>%
  group_by(NhCoord20, merged_annot_cluster) %>%
  summarise(count = n()) %>%
  spread(merged_annot_cluster, count, fill = 0)

# Convert NhCoord20_anno to row names and remove it as a column
cell_counts_matrix <- as.matrix(cell_counts[,-1])
rownames(cell_counts_matrix) <- cell_counts$NhCoord20

# Calculate centroids (average profile for each NhCoord20_anno cluster)
centroids <- cell_counts %>%
  group_by(NhCoord20) %>%
  summarise(across(everything(), mean))

# Convert centroids to matrix and set row names
centroids_matrix <- as.matrix(centroids[,-1])
rownames(centroids_matrix) <- centroids$NhCoord20

# Calculate tissue averages
tissue_avgs <- colMeans(cell_counts_matrix)

# Calculate fold changes
calculate_fold_change <- function(row, tissue_avgs) {
  niche_clusters <- row + tissue_avgs
  niche_sum <- sum(niche_clusters)
  log2((niche_clusters / niche_sum) / tissue_avgs)
}

fc_matrix <- t(apply(centroids_matrix, 1, calculate_fold_change, tissue_avgs))

# Rescale the fold changes to be between -3 and 3
rescale_to_range <- function(x, new_min = -3, new_max = 3) {
  old_min <- min(x)
  old_max <- max(x)
  new_min + ((x - old_min) * (new_max - new_min) / (old_max - old_min))
}

fc_matrix_rescaled <- apply(fc_matrix, 2, rescale_to_range)

# Cap values at -3 and 3
fc_matrix_rescaled[fc_matrix_rescaled < -3] <- -3
fc_matrix_rescaled[fc_matrix_rescaled > 3] <- 3

# Prepare the heatmap
# Define the color mapping function
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))

fc_matrix_rescaled <- as.data.frame(fc_matrix_rescaled)

# Create the heatmap
# Set graphics device options (if plotting to a file)
options(bitmapType = "cairo")

# Create the heatmap
heatmap <- Heatmap(fc_matrix_rescaled,
                   name = "Log2 Fold Change",
                   col = col_fun,
                   cluster_rows = TRUE,
                   cluster_columns = TRUE,
                   show_row_names = TRUE,
                   show_column_names = TRUE,
                   column_names_rot = 45,
                   row_names_side = "left",
                   column_title_side = 'bottom',
                   column_title = "Cell Types",
                   row_title = "Neighborhoods",
                   rect_gp = gpar(col = NA, lwd = 0),  # Negative line width
                   border = FALSE,
                   #width = unit(10, "inches"),  # Increase overall size
                   #height = unit(8, "inches"),
                   heatmap_legend_param = list(
                     title = "Normalized cell type enrichment score",
                     title_position = "leftcenter-rot",
                     title_gp = gpar(fontsize = 10),
                     at = c(-3, 0, 3),
                     labels = c("-3", "0", "3"),
                     legend_height = unit(4, "cm"),
                     grid_width = unit(0.5, "cm")
                   ))

# Draw the heatmap
pdf('ComplexHeatmap_celltypes_20neighborhood_complexheatmap.pdf', width = 6, height = 5)
draw(heatmap)
dev.off()
```

```{r S2B--RNA neighborhood heatmap (20 clusters)}
load("CosMX_TMA/CosMX_RNA_merged.rda")

CosMX_RNA_merged$annot_cluster2[grep('inflammatory', CosMX_RNA_merged$annot_cluster2)] <- 'Fibroblast_VEGFA_iCAFs'

# Create a table of cell counts
cell_counts <- CosMX_RNA_merged@meta.data %>%
  group_by(k10_NhCoord20, annot_cluster2) %>%
  summarise(count = n()) %>%
  spread(annot_cluster2, count, fill = 0)

# Convert k10_NhCoord20_anno to row names and remove it as a column
cell_counts_matrix <- as.matrix(cell_counts[,-1])
rownames(cell_counts_matrix) <- cell_counts$k10_NhCoord20

# Calculate centroids (average profile for each k10_NhCoord20_anno cluster)
centroids <- cell_counts %>%
  group_by(k10_NhCoord20) %>%
  summarise(across(everything(), mean))

# Convert centroids to matrix and set row names
centroids_matrix <- as.matrix(centroids[,-1])
rownames(centroids_matrix) <- centroids$k10_NhCoord20

# Calculate tissue averages
tissue_avgs <- colMeans(cell_counts_matrix)

# Calculate fold changes
calculate_fold_change <- function(row, tissue_avgs) {
  niche_clusters <- row + tissue_avgs
  niche_sum <- sum(niche_clusters)
  log2((niche_clusters / niche_sum) / tissue_avgs)
}

fc_matrix <- t(apply(centroids_matrix, 1, calculate_fold_change, tissue_avgs))

# Rescale the fold changes to be between -3 and 3
rescale_to_range <- function(x, new_min = -3, new_max = 3) {
  old_min <- min(x)
  old_max <- max(x)
  new_min + ((x - old_min) * (new_max - new_min) / (old_max - old_min))
}

fc_matrix_rescaled <- apply(fc_matrix, 2, rescale_to_range)

# Cap values at -3 and 3
fc_matrix_rescaled[fc_matrix_rescaled < -3] <- -3
fc_matrix_rescaled[fc_matrix_rescaled > 3] <- 3

write.csv(fc_matrix, 'RNA_fc_matrix.csv')
write.csv(fc_matrix_rescaled, 'RNA_fc_matrix_rescaled.csv')

# Prepare the heatmap
# Define the color mapping function
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))

# Create the heatmap
heatmap <- Heatmap(fc_matrix_rescaled,
                   name = "Log2 Fold Change",
                   col = col_fun,
                   cluster_rows = TRUE,
                   cluster_columns = TRUE,
                   show_row_names = TRUE,
                   show_column_names = TRUE,
                   column_names_rot = 45,
                   row_names_side = "left",
                   column_title_side = 'bottom',
                   column_title = "Cell Types",
                   row_title = "Neighborhoods",
                   heatmap_legend_param = list(
                     title = "Normalized cell type enrichment score",
                     title_position = "leftcenter-rot",
                     title_gp = gpar(fontsize = 10),
                     at = c(-3, 0, 3),
                     labels = c("-3", "0", "3"),
                     legend_height = unit(4, "cm"),
                     grid_width = unit(0.5, "cm")
                   ))

# Draw the heatmap
pdf("RNA_celltypes_per_neighborhood_complexheatmap.pdf", width = 8, height = 6)
draw(heatmap)
dev.off()

transposed_heatmap <- Heatmap(as.data.frame(t(fc_matrix_rescaled)),
                              name = "Log2 Fold Change",
                              col = col_fun,
                              cluster_rows = TRUE,
                              cluster_columns = TRUE,
                              show_row_names = TRUE,
                              show_column_names = TRUE,
                              column_names_rot = 45,
                              row_names_side = "left",
                              column_title_side = 'bottom',
                              row_title = "Cell Types",
                              column_title = "Neighborhoods",
                              show_row_dend = FALSE,  # This line removes the row dendrogram
                              show_column_dend = FALSE,  # This line removes the column dendrogram (if you want)
                              heatmap_legend_param = list(
                                title = "Normalized cell type enrichment score",
                                title_position = "leftcenter-rot",
                                title_gp = gpar(fontsize = 10),
                                at = c(-3, 0, 3),
                                labels = c("-3", "0", "3"),
                                legend_height = unit(4, "cm"),
                                grid_width = unit(0.5, "cm")
                              ))
pdf('RNA_tranposed_celltypes_per_neighborhood_complexheatmap.pdf', width = 5, height = 5)
draw(transposed_heatmap)
dev.off()
```

```{r S3 - distribution of neighborhoods across FOVs}
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", 
                    "#FF7F00", "#FDB462", "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", 
                    "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", 
                    "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# FOV plotting
meta <- CosMX_RNA_merged[[c('tma_fov_id', 'x_pixel', 'y_pixel', 'k10_NhCoord20_anno', 'Response', 'annot_cluster2')]]

unique(meta$k10_NhCoord20_anno)
#[1] "Bcell_Plasma"             "Endothelial"              "Tumor_Immune_Mixed"       "DC_T_iCAF_Tumor_Mixed"    "Macrophage_High"          "CAF_Immune_Mixed"         "CAFs"                    
#[8] "Tumor_High"               "Myeloid_K17+_Tumor_Mixed"

unique(meta$annot_cluster2)
#[1] "Endothelials"                           "Bcells"                                 "Plasma"                                 "Fibroblast_myCAFs"                     
#[5] "Monocytes"                              "Tcells_CD4+"                            "Tumors_Others"                          "Fibroblast_apCAFs"                     
#[9] "Macrophages"                            "Tumors_KRT19+"                          "DCs"                                    "Tregs"                                 
#[13] "Tumors_HIF1A+"                          "Fibroblast_VEGFA_inflammatorylike_CAFs" "TcellsCD8+"                             "Tumors_KRT17+"    

# looped version that makes a plot for every single neighborhood
nhs <- unique(meta$k10_NhCoord20_anno)

meta <- meta %>% mutate(annot_cluster3 = case_when(
  grepl("CD8", annot_cluster2) ~ "CD8+ T cells",
  grepl("DC", annot_cluster2) ~ "DCs",
  grepl('CD4', annot_cluster2) ~ 'CD4+ T cells',
  grepl('Treg', annot_cluster2) ~ 'Tregs',
  grepl('Tumor', annot_cluster2) ~ 'Tumor cells',
  grepl('Bcells|Plasma|Mono|Macro|Endo', annot_cluster2) ~ 'Other',
  grepl("myCAF", annot_cluster2) ~"myCAFs",
  grepl('inflammatory', annot_cluster2) ~ 'iCAFs',
  grepl('apCAF', annot_cluster2) ~ 'apCAFs'))


colors <- color_clusters[1:length(nhs)]

# Plot for 'R' response
ggplot(meta[meta$Response == 'R',], aes(x = x_pixel, y = y_pixel, color = k10_NhCoord20_anno, size = 0.5)) + 
  geom_point() +
  theme_classic() + 
  facet_wrap(~ tma_fov_id) + 
  scale_color_manual(values = colors) +
  scale_size_identity() +
  scale_alpha_identity()

ggsave(paste('RNA_R', 'multicolor_FOV_plotting.pdf', sep = '_'), width = 14, height = 13)

# Plot for 'NR' response
ggplot(meta[meta$Response == 'NR',], aes(x = x_pixel, y = y_pixel, color = k10_NhCoord20_anno, size = 0.5)) + 
  geom_point() +
  theme_classic() + 
  facet_wrap(~ tma_fov_id) + 
  scale_color_manual(values = colors) +
  scale_size_identity() +
  scale_alpha_identity()

ggsave(paste('RNA_NR', 'multicolor_FOV_plotting.pdf', sep = '_'), width = 14, height = 13)

meta <- CosMx_Protein_log_norm[[c('tma_fov_id', 'x_FOV_px', 'y_FOV_px', 'NhCoord20_anno_new', 'Response', 'merged_annot_cluster')]]
nhs <- unique(meta$NhCoord20_anno_new)
colors <- color_clusters[1:length(nhs)]

# Plot for 'R' response
ggplot(meta[meta$Response == 'R',], aes(x = x_FOV_px, y = y_FOV_px, color = NhCoord20_anno_new, size = 0.5)) + 
  geom_point() +
  theme_classic() + 
  facet_wrap(~ tma_fov_id) + 
  scale_color_manual(values = colors) +
  scale_size_identity() +
  scale_alpha_identity()

ggsave(paste('Protein_R', 'multicolor_FOV_plotting.pdf', sep = '_'), width = 14, height = 13)


# Plot for 'NR' response
ggplot(meta[meta$Response == 'NR',], aes(x = x_FOV_px, y = y_FOV_px, color = NhCoord20_anno_new, size = 0.5)) + 
  geom_point() +
  theme_classic() + 
  facet_wrap(~ tma_fov_id) + 
  scale_color_manual(values = colors) +
  scale_size_identity() +
  scale_alpha_identity()

ggsave(paste('Protein_NR', 'multicolor_FOV_plotting.pdf', sep = '_'), width = 14, height = 13)
```

```{r S5}
p_coex<-SpatialFeaturePlot(object = ck17_5,features = c('CXCL9_CXCR3_nh_coex_SCT'),pt.size.factor = 2000)
p1_coex<-p_coex+theme(legend.position = 'bottom') + annotate("rect", xmin = 160, xmax = 320, ymin = 320, ymax = 440,
                                                fill = "transparent",color="black",size=2.5) + labs(fill='CXCL9-CXCR3')
ggsave(filename = '/Volumes/hqdinh2/Lab_Manuscripts/SUBMITTED_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/SpatialFeaturePlots/CXCL9_CXCR3region_ck17_5.pdf',plot = p1_coex,device = 'pdf')

p_cxcl9<-SpatialFeaturePlot(object = ck17_5,features = c('CXCL9'),pt.size.factor = 2000)
p1_cxcl9<-p_cxcl9+theme(legend.position = 'bottom') + annotate("rect", xmin = 160, xmax = 320, ymin = 320, ymax = 440,
                                                   fill = "transparent",color="black",size=2.5)
ggsave(filename = '/Volumes/hqdinh2/Lab_Manuscripts/SUBMITTED_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/SpatialFeaturePlots/CXCL9region_ck17_5.pdf',plot = p1_cxcl9,device = 'pdf')

p_cxcr3<-SpatialFeaturePlot(object = ck17_5,features = c('CXCR3'),pt.size.factor = 2000)
p1_cxcr3<-p_cxcr3+theme(legend.position = 'bottom') + annotate("rect", xmin = 160, xmax = 320, ymin = 320, ymax = 440,
                                                   fill = "transparent",color="black",size=2.5)
ggsave(filename = '/Volumes/hqdinh2/Lab_Manuscripts/SUBMITTED_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/SpatialFeaturePlots/CXCR3region_ck17_5.pdf',plot = p1_cxcr3,device = 'pdf')
```

```{r S6A--Chemokine pathway rank plot (sender receiver only) with jitter}
load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_cytokine/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# non-responder pre-treatment
nr_pre <- as.data.frame(nr_pre_cellchat@net$count) %>%
  rownames_to_column()
nr_pre <- nr_pre[grep('Mac|Mon|DC', nr_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_pre))]
nr_pre <- nr_pre %>%
  pivot_longer(cols = 2:ncol(nr_pre), names_to = 'receiver', values_to = 'NR_pre_prob') #%>%
#rename(sender = rowname)
nr_pre$SR <- paste(nr_pre$rowname, nr_pre$receiver, sep = '_')

# non-responder post-treatment
nr_post <- as.data.frame(nr_post_cellchat@net$count) %>%
  rownames_to_column()
nr_post <- nr_post[grep('Mac|Mon|DC', nr_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_post))]
nr_post <- nr_post %>%
  pivot_longer(cols = 2:ncol(nr_post), names_to = 'receiver', values_to = 'NR_post_prob') #%>%
#rename(sender = rowname)
nr_post$SR <- paste(nr_post$rowname, nr_post$receiver, sep = '_')

# Responder pre-treatment
r_pre <- as.data.frame(r_pre_cellchat@net$count) %>%
  rownames_to_column()
r_pre <- r_pre[grep('Mac|Mon|DC', r_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_pre))]
r_pre <- r_pre %>%
  pivot_longer(cols = 2:ncol(r_pre), names_to = 'receiver', values_to = 'R_pre_prob') #%>%
#rename(sender = rowname)
r_pre$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# Responder post-treatment
r_post <- as.data.frame(r_post_cellchat@net$count) %>%
  rownames_to_column()
r_post <- r_post[grep('Mac|Mon|DC', r_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_post))]
r_post <- r_post %>%
  pivot_longer(cols = 2:ncol(r_post), names_to = 'receiver', values_to = 'R_post_prob') #%>%
#rename(sender = rowname)
r_post$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC))

post <- merge(r_post, nr_post, by = 'SR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC))

post <- post[!post$rowname.x == 'Mac_SPP1',]

# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 0.2 ~ "R_enriched",
  pre$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 0.2 ~ "R_enriched",
  post$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

pre <- pre[pre$log2FC != Inf,]
post <- post[post$log2FC != Inf,]

pre <- pre %>%
  mutate(rank = row_number())

post <- post %>%
  mutate(rank = row_number())

# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00",
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7",
                      'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Function to create the label grob
create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}

# Jitter strength (adjust this value)
jitter_strength <- 0.05

# Function to create the rank plot with grob jitter
create_rank_plot <- function(data, title) {
  p <- ggplot(data, aes(x = rank, y = log2FC)) +
    # Add white dots for points outside -0.2 and 0.2
    geom_point(data = subset(data, log2FC < -0.2 | log2FC > 0.2),
               color = "white", size = 2) +
    # Add black dots for points between -0.2 and 0.2
    geom_point(data = subset(data, log2FC >= -0.2 & log2FC <= 0.2),
               color = "black", size = 1) +
    theme_classic() +
    labs(title = title,
         x = "CCI rank", y = "log2FC(R/NR count)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
          legend.position = "none", axis.text = element_text(size = 12),
          axis.title = element_text(size = 18, face = "bold"))

  # Add custom annotations with jitter
  significant_points <- subset(data, log2FC > 0.2 | log2FC < -0.2)
  for (i in 1:nrow(significant_points)) {
    label_grob <- create_label_grob(
      significant_points$rowname.x[i],
      significant_points$receiver.x[i],
      sender_colors[significant_points$rowname.x[i]],
      receiver_colors[significant_points$receiver.x[i]]
    )

    # Apply jitter to ymin and ymax
    jitter_value <- runif(1, -jitter_strength, jitter_strength)

    p <- p + annotation_custom(
      grob = label_grob,
      xmin = significant_points$rank[i] - 0.75,
      xmax = significant_points$rank[i] + 0.75,
      ymin = significant_points$log2FC[i] - 0.2 + jitter_value,  # Jittered ymin
      ymax = significant_points$log2FC[i] + 0.2 + jitter_value   # Jittered ymax
    )
  }

  # Add horizontal lines at y = 0.2 and y = -0.2
  p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

  # Add legends for sender and receiver colors with correct order and appearance
  p <- p + scale_color_manual(name = "Sender",
                               values = sender_colors,
                               breaks = names(sender_colors),
                               guide = guide_legend(order = 1,
                                                    override.aes = list(shape = 21,
                                                                        size = 5,
                                                                        fill = NA))) +
    scale_fill_manual(name = "Receiver",
                      values = receiver_colors,
                      breaks = names(receiver_colors),
                      guide = guide_legend(order = 2,
                                           override.aes = list(shape = 21,
                                                               size = 5,
                                                               color = NA)))

  # Adjust legend appearance and layout
  p <- p + theme(
    legend.key = element_rect(colour = NA),
    legend.key.size = unit(1.2, "cm"),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    legend.position = "none",
    legend.box = "vertical",
    legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
    legend.box.margin = margin(0, 0, 0, 0),
    legend.spacing.x = unit(0, 'cm'),
    legend.spacing.y = unit(0, 'cm'),
    plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
  )

  # Adjust the guide for sender legend to use two rows, keep receiver legend as one row
  p <- p + guides(
    color = guide_legend(nrow = 2, byrow = TRUE, order = 1,
                         override.aes = list(shape = 21,
                                             size = 6,
                                             fill = NA)),
    fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                        override.aes = list(shape = 21,
                                            size = 6,
                                            color = NA))
  )

  return(p)
}

# Create pre-treatment plot
pre_plot <- create_rank_plot(pre, "Chemokine Pre-ICB")
# Save the plot
pdf('ChemokinePathway_PreTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(pre_plot)
dev.off()

# Create post-treatment plot
post_plot <- create_rank_plot(post, "Chemokine Post-ICB")

# Save the plot
pdf('ChemokinePathway_PostTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(post_plot)
dev.off()

```

```{r S6A--UpSet plot mregDC sender}
load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma/all_cellchat_objs.rda')

#combined upset plots
create_combined_upset_plot <- function(cellchat, sender, target, group1, group2, desired_order, output_file) {
  library(dplyr)
  library(ComplexHeatmap)
  library(UpSetR)
  
  # Extract and prepare the interaction data for each group
  cellchat_count_group1 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group1]] %>% 
    select(c('target', 'ligand', 'receptor'))
  cellchat_count_group2 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group2]] %>% 
    select(c('target', 'ligand', 'receptor'))
  
  # Create interaction string without the target/receiver
  cellchat_count_group1$interaction <- paste(cellchat_count_group1$ligand, cellchat_count_group1$receptor, sep = '->')
  cellchat_count_group2$interaction <- paste(cellchat_count_group2$ligand, cellchat_count_group2$receptor, sep = '->')
  
  # Create a list of interactions for each receiver
  interaction_list1 <- split(cellchat_count_group1$interaction, cellchat_count_group1$target)
  interaction_list2 <- split(cellchat_count_group2$interaction, cellchat_count_group2$target)
  
  # Filter out sets with a list length of zero
  interaction_list1 <- interaction_list1[sapply(interaction_list1, length) > 0]
  interaction_list2 <- interaction_list2[sapply(interaction_list2, length) > 0]
  
  # Append group IDs to the set names
  names(interaction_list1) <- paste(names(interaction_list1), group1, sep = "_")
  names(interaction_list2) <- paste(names(interaction_list2), group2, sep = "_")
  
  # Combine the interaction lists
  combined_interaction_list <- c(interaction_list1, interaction_list2)
  
  # Create a combination matrix
  comb_mat_combined <- make_comb_mat(combined_interaction_list)
  
  # Filter out empty columns (those with no intersection size)
  non_empty_columns <- comb_degree(comb_mat_combined) > 0
  comb_mat_combined_filtered <- comb_mat_combined[, non_empty_columns]
  
  # Create a custom color vector based on the set combinations
  intersection_colors <- sapply(seq_len(ncol(comb_mat_combined_filtered)), function(i) {
    sets_in_comb <- rownames(comb_mat_combined_filtered)[comb_mat_combined_filtered[,i] == 1]
    r_sets <- sum(grepl("_R$", sets_in_comb))
    nr_sets <- sum(grepl("_NR$", sets_in_comb))
    
    if (r_sets > 0 && nr_sets == 0) {
      return("#B71C1C")  # Color for "_R" only
    } else if (nr_sets > 0 && r_sets == 0) {
      return('#2196F3')  # Color for "_NR" only
    } else if (r_sets > 0 && nr_sets > 0) {
      return("grey20")  # Color for both
    } else {
      return("grey50")  # Default color
    }
  })
  
  # Generate the UpSet plot
  tryCatch({
    grDevices::pdf(output_file, width = 6, height = 4)
    print(UpSet(comb_mat_combined_filtered, 
                pt_size = unit(5, "mm"), 
                lwd = 3, 
                comb_col = intersection_colors, 
                bg_col = c("grey90", "grey100"), 
                bg_pt_col = "grey70",
                set_order = desired_order))
  }, finally = {
    grDevices::dev.off()
  })
  
  # Check if the file was created successfully
  if (file.exists(output_file) && file.size(output_file) > 4096) {
    message("PDF file created successfully: ", output_file)
  } else {
    warning("PDF file creation may have failed or file is too small: ", output_file)
  }
  
  # Sanity check: Create a table of the number of interactions per set
  interactions_per_set <- sapply(combined_interaction_list, length)
  interactions_table <- data.frame(
    Set = names(interactions_per_set),
    Number_of_Interactions = interactions_per_set
  )
  
  # Sanity check: Get contributing interactions for each set
  contributing_interactions <- lapply(names(combined_interaction_list), function(set_name) {
    data.frame(
      Set = set_name,
      Interaction = combined_interaction_list[[set_name]]
    )
  })
  contributing_interactions <- do.call(rbind, contributing_interactions)
  
  # Sanity check: Get intersections and their sizes
  intersections <- comb_size(comb_mat_combined_filtered)
  intersection_sizes <- data.frame(
    Intersection = names(intersections),
    Size = intersections
  )
  
  # Create a list of returned objects
  returned_objects <- list(
    interactions_table = interactions_table,
    contributing_interactions = contributing_interactions,
    intersection_sizes = intersection_sizes,
    comb_mat = comb_mat_combined_filtered, 
    combined_interaction_list = combined_interaction_list
  )
  
  # Return the list of objects
  return(returned_objects)
}


# Example usage
original_receivers = c('IL7R_CD4', 'ITGAE_CD8', 'GZMK_CD8', 'NR4A2_CD8', 'CXCL13_Tcells', 'Tregs')

# Duplicate the vector and append "_R" and "_NR"
receivers_R <- paste(original_receivers, "_R", sep = "")
receivers_NR <- paste(original_receivers, "_NR", sep = "")

# Combine and rearrange the order
combined_receivers <- c(receivers_NR, receivers_R)

mreg_post <- create_combined_upset_plot(cellchat = post.cellchat, 
                           sender = 'mregDC_LAMP3',
                           target = unique(grep('CD4|CD8|Tcells|Tregs', post.cellchat@meta$consensus_clusters, value = T)), 
                           group1 = "NR", 
                           group2 = "R", 
                           desired_order = combined_receivers, 
                           output_file = "post_tx_mregDC_combined_UpsetPlot.pdf")
mreg_pre <- create_combined_upset_plot(cellchat = pre.cellchat, 
                                        sender = 'mregDC_LAMP3',
                                        target = unique(grep('CD4|CD8|Tcells|Tregs', pre.cellchat@meta$consensus_clusters, value = T)), 
                                        group1 = "NR", 
                                        group2 = "R", 
                                        desired_order = combined_receivers, 
                                        output_file = "pre_tx_mregDC_combined_UpsetPlot.pdf")
```

```{r S6B--Complement pathway rank plot (sender receiver only)}
library(ggplot2)
library(grid)
library(dplyr)
library(tidyr)

load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_complement/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# non-responder pre-treatment
nr_pre <- as.data.frame(nr_pre_cellchat@net$count) %>%
  rownames_to_column()
nr_pre <- nr_pre[grep('Mac|Mon|DC', nr_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_pre))]
nr_pre <- nr_pre %>%
  pivot_longer(cols = 2:ncol(nr_pre), names_to = 'receiver', values_to = 'NR_pre_prob') #%>%
#rename(sender = rowname)
nr_pre$SR <- paste(nr_pre$rowname, nr_pre$receiver, sep = '_')

# non-responder post-treatment
nr_post <- as.data.frame(nr_post_cellchat@net$count) %>%
  rownames_to_column()
nr_post <- nr_post[grep('Mac|Mon|DC', nr_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_post))]
nr_post <- nr_post %>%
  pivot_longer(cols = 2:ncol(nr_post), names_to = 'receiver', values_to = 'NR_post_prob') #%>%
#rename(sender = rowname)
nr_post$SR <- paste(nr_post$rowname, nr_post$receiver, sep = '_')

# Responder pre-treatment
r_pre <- as.data.frame(r_pre_cellchat@net$count) %>%
  rownames_to_column()
r_pre <- r_pre[grep('Mac|Mon|DC', r_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_pre))]
r_pre <- r_pre %>%
  pivot_longer(cols = 2:ncol(r_pre), names_to = 'receiver', values_to = 'R_pre_prob') #%>%
#rename(sender = rowname)
r_pre$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# Responder post-treatment
r_post <- as.data.frame(r_post_cellchat@net$count) %>%
  rownames_to_column()
r_post <- r_post[grep('Mac|Mon|DC', r_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_post))]
r_post <- r_post %>%
  pivot_longer(cols = 2:ncol(r_post), names_to = 'receiver', values_to = 'R_post_prob') #%>%
#rename(sender = rowname)
r_post$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC))

post <- merge(r_post, nr_post, by = 'SR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC))

post <- post[!post$rowname.x == 'Mac_SPP1',]

# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 0.2 ~ "R_enriched",
  pre$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 0.2 ~ "R_enriched",
  post$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

pre <- pre[pre$log2FC != Inf,]
post <- post[post$log2FC != Inf,]

pre <- pre %>%
  mutate(rank = row_number())

post <- post %>%
  mutate(rank = row_number())

# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00",
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7",
                      'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Function to create the label grob
create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}

# Jitter strength (adjust this value)
jitter_strength <- 0.05

# Create the base plot with all points--post-treatment
# Pre-treatment plot
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(pre, log2FC < -0.2 | log2FC > 0.2),
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(pre, log2FC >= -0.2 & log2FC <= 0.2),
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Complement Pre-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(pre, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )

  # Apply jitter to ymin and ymax
  jitter_value <- runif(1, -jitter_strength, jitter_strength)  # Random jitter

  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2 + jitter_value,
    ymax = significant_points$log2FC[i] + 0.2 + jitter_value
  )
}

# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender",
                             values = sender_colors,
                             breaks = names(sender_colors),
                             guide = guide_legend(order = 1,
                                                  override.aes = list(shape = 21,
                                                                      size = 5,
                                                                      fill = NA))) +
  scale_fill_manual(name = "Receiver",
                     values = receiver_colors,
                     breaks = names(receiver_colors),
                     guide = guide_legend(order = 2,
                                          override.aes = list(shape = 21,
                                                              size = 5,
                                                              color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1,
                       override.aes = list(shape = 21,
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21,
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('ComplementPathway_PreTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()


# ################################################################################
# ####### POST-TX
##################################################################################
# sender and receiver data is the same

# Create the base plot with all points--post-treatment

p <- ggplot(post, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(post, log2FC < -0.2 | log2FC > 0.2),
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(post, log2FC >= -0.2 & log2FC <= 0.2),
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Complement Post-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(post, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )

  # Apply jitter to ymin and ymax
  jitter_value <- runif(1, -jitter_strength, jitter_strength)  # Random jitter

  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2 + jitter_value,
    ymax = significant_points$log2FC[i] + 0.2 + jitter_value
  )
}


# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender",
                             values = sender_colors,
                             breaks = names(sender_colors),
                             guide = guide_legend(order = 1,
                                                  override.aes = list(shape = 21,
                                                                      size = 5,
                                                                      fill = NA))) +
  scale_fill_manual(name = "Receiver",
                     values = receiver_colors,
                     breaks = names(receiver_colors),
                     guide = guide_legend(order = 2,
                                          override.aes = list(shape = 21,
                                                              size = 5,
                                                              color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1,
                       override.aes = list(shape = 21,
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21,
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('ComplementPathway_PostTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()

```

```{r S6B--UpSet plot Mac CXCL9 sender}
load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma/all_cellchat_objs.rda')

#combined upset plots
create_combined_upset_plot <- function(cellchat, sender, target, group1, group2, desired_order, output_file) {
  library(dplyr)
  library(ComplexHeatmap)
  library(UpSetR)
  
  # Extract and prepare the interaction data for each group
  cellchat_count_group1 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group1]] %>% 
    select(c('target', 'ligand', 'receptor'))
  cellchat_count_group2 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group2]] %>% 
    select(c('target', 'ligand', 'receptor'))
  
  # Create interaction string without the target/receiver
  cellchat_count_group1$interaction <- paste(cellchat_count_group1$ligand, cellchat_count_group1$receptor, sep = '->')
  cellchat_count_group2$interaction <- paste(cellchat_count_group2$ligand, cellchat_count_group2$receptor, sep = '->')
  
  # Create a list of interactions for each receiver
  interaction_list1 <- split(cellchat_count_group1$interaction, cellchat_count_group1$target)
  interaction_list2 <- split(cellchat_count_group2$interaction, cellchat_count_group2$target)
  
  # Filter out sets with a list length of zero
  interaction_list1 <- interaction_list1[sapply(interaction_list1, length) > 0]
  interaction_list2 <- interaction_list2[sapply(interaction_list2, length) > 0]
  
  # Append group IDs to the set names
  names(interaction_list1) <- paste(names(interaction_list1), group1, sep = "_")
  names(interaction_list2) <- paste(names(interaction_list2), group2, sep = "_")
  
  # Combine the interaction lists
  combined_interaction_list <- c(interaction_list1, interaction_list2)
  
  # Create a combination matrix
  comb_mat_combined <- make_comb_mat(combined_interaction_list)
  
  # Filter out empty columns (those with no intersection size)
  non_empty_columns <- comb_degree(comb_mat_combined) > 0
  comb_mat_combined_filtered <- comb_mat_combined[, non_empty_columns]
  
  # Create a custom color vector based on the set combinations
  intersection_colors <- sapply(seq_len(ncol(comb_mat_combined_filtered)), function(i) {
    sets_in_comb <- rownames(comb_mat_combined_filtered)[comb_mat_combined_filtered[,i] == 1]
    r_sets <- sum(grepl("_R$", sets_in_comb))
    nr_sets <- sum(grepl("_NR$", sets_in_comb))
    
    if (r_sets > 0 && nr_sets == 0) {
      return("#B71C1C")  # Color for "_R" only
    } else if (nr_sets > 0 && r_sets == 0) {
      return('#2196F3')  # Color for "_NR" only
    } else if (r_sets > 0 && nr_sets > 0) {
      return("grey20")  # Color for both
    } else {
      return("grey50")  # Default color
    }
  })
  
  # Generate the UpSet plot
  tryCatch({
    grDevices::pdf(output_file, width = 6, height = 4)
    print(UpSet(comb_mat_combined_filtered, 
                pt_size = unit(5, "mm"), 
                lwd = 3, 
                comb_col = intersection_colors, 
                bg_col = c("grey90", "grey100"), 
                bg_pt_col = "grey70",
                set_order = desired_order))
  }, finally = {
    grDevices::dev.off()
  })
  
  # Check if the file was created successfully
  if (file.exists(output_file) && file.size(output_file) > 4096) {
    message("PDF file created successfully: ", output_file)
  } else {
    warning("PDF file creation may have failed or file is too small: ", output_file)
  }
  
  # Sanity check: Create a table of the number of interactions per set
  interactions_per_set <- sapply(combined_interaction_list, length)
  interactions_table <- data.frame(
    Set = names(interactions_per_set),
    Number_of_Interactions = interactions_per_set
  )
  
  # Sanity check: Get contributing interactions for each set
  contributing_interactions <- lapply(names(combined_interaction_list), function(set_name) {
    data.frame(
      Set = set_name,
      Interaction = combined_interaction_list[[set_name]]
    )
  })
  contributing_interactions <- do.call(rbind, contributing_interactions)
  
  # Sanity check: Get intersections and their sizes
  intersections <- comb_size(comb_mat_combined_filtered)
  intersection_sizes <- data.frame(
    Intersection = names(intersections),
    Size = intersections
  )
  
  # Create a list of returned objects
  returned_objects <- list(
    interactions_table = interactions_table,
    contributing_interactions = contributing_interactions,
    intersection_sizes = intersection_sizes,
    comb_mat = comb_mat_combined_filtered, 
    combined_interaction_list = combined_interaction_list
  )
  
  # Return the list of objects
  return(returned_objects)
}


# Example usage
original_receivers = c('IL7R_CD4', 'ITGAE_CD8', 'GZMK_CD8', 'NR4A2_CD8', 'CXCL13_Tcells', 'Tregs')

# Duplicate the vector and append "_R" and "_NR"
receivers_R <- paste(original_receivers, "_R", sep = "")
receivers_NR <- paste(original_receivers, "_NR", sep = "")

# Combine and rearrange the order
combined_receivers <- c(receivers_NR, receivers_R)

mac_post <- create_combined_upset_plot(cellchat = post.cellchat, 
                           sender = 'Mac_CXCL9',
                           target = unique(grep('CD4|CD8|Tcells|Tregs', post.cellchat@meta$consensus_clusters, value = T)), 
                           group1 = "NR", 
                           group2 = "R", 
                           desired_order = combined_receivers, 
                           output_file = "post_tx_Mac_CXCL9_combined_UpsetPlot.pdf")
mac_pre <- create_combined_upset_plot(cellchat = pre.cellchat, 
                                        sender = 'Mac_CXCL9',
                                        target = unique(grep('CD4|CD8|Tcells|Tregs', pre.cellchat@meta$consensus_clusters, value = T)), 
                                        group1 = "NR", 
                                        group2 = "R", 
                                        desired_order = combined_receivers, 
                                        output_file = "pre_tx_Mac_CXCL9_combined_UpsetPlot.pdf")
```

```{r S3C--Costim/Coinhib pathway rank plot (sender receiver only)}
load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_costim_coinhib/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# non-responder pre-treatment
nr_pre <- as.data.frame(nr_pre_cellchat@net$count) %>% 
  rownames_to_column() 
nr_pre <- nr_pre[grep('Mac|Mon|DC', nr_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_pre))]
nr_pre <- nr_pre %>%
  pivot_longer(cols = 2:ncol(nr_pre), names_to = 'receiver', values_to = 'NR_pre_prob') #%>%
  #rename(sender = rowname)
nr_pre$SR <- paste(nr_pre$rowname, nr_pre$receiver, sep = '_')

# non-responder post-treatment
nr_post <- as.data.frame(nr_post_cellchat@net$count) %>% 
  rownames_to_column()
nr_post <- nr_post[grep('Mac|Mon|DC', nr_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_post))]
nr_post <- nr_post %>%
  pivot_longer(cols = 2:ncol(nr_post), names_to = 'receiver', values_to = 'NR_post_prob') #%>%
  #rename(sender = rowname)
nr_post$SR <- paste(nr_post$rowname, nr_post$receiver, sep = '_')

# Responder pre-treatment
r_pre <- as.data.frame(r_pre_cellchat@net$count) %>% 
  rownames_to_column()
r_pre <- r_pre[grep('Mac|Mon|DC', r_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_pre))]
r_pre <- r_pre %>%
  pivot_longer(cols = 2:ncol(r_pre), names_to = 'receiver', values_to = 'R_pre_prob') #%>%
  #rename(sender = rowname)
r_pre$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# Responder post-treatment
r_post <- as.data.frame(r_post_cellchat@net$count) %>% 
  rownames_to_column()
r_post <- r_post[grep('Mac|Mon|DC', r_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_post))]
r_post <- r_post %>%
  pivot_longer(cols = 2:ncol(r_post), names_to = 'receiver', values_to = 'R_post_prob') #%>%
  #rename(sender = rowname)
r_post$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')



# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC)) 
post <- merge(r_post, nr_post, by = 'SR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) 


# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 0.2 ~ "R_enriched",
  pre$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 0.2 ~ "R_enriched",
  post$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

pre <- pre[pre$log2FC != Inf,]
post <- post[post$log2FC != Inf,]

pre <- pre %>%
  mutate(rank = row_number())
post <- post %>%
  mutate(rank = row_number())



# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create the base plot with all points--post-treatment

create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(pre, log2FC < -0.2 | log2FC > 0.2), 
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(pre, log2FC >= -0.2 & log2FC <= 0.2), 
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Costim/Coinhib Pre-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(pre, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2,
    ymax = significant_points$log2FC[i] + 0.2
  )
}

# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 21, 
                                                                     size = 5, 
                                                                     fill = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 21, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1, 
                       override.aes = list(shape = 21, 
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21, 
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('CostimCoinhibPathway_PreTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()







post <- post[!post$rowname.x == 'Mac_SPP1',]



sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")
create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}
p <- ggplot(post, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(post, log2FC < -0.2 | log2FC > 0.2), 
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(post, log2FC >= -0.2 & log2FC <= 0.2), 
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Costim/Coinhib Post-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(post, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2,
    ymax = significant_points$log2FC[i] + 0.2
  )
}

# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 21, 
                                                                     size = 5, 
                                                                     fill = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 21, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1, 
                       override.aes = list(shape = 21, 
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21, 
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('CostimCoinhibPathway_PostTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()
```

```{r S6C--UpSet plot cDC1 sender}
load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma/all_cellchat_objs.rda')

#combined upset plots
create_combined_upset_plot <- function(cellchat, sender, target, group1, group2, desired_order, output_file) {
  library(dplyr)
  library(ComplexHeatmap)
  library(UpSetR)
  
  # Extract and prepare the interaction data for each group
  cellchat_count_group1 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group1]] %>% 
    select(c('target', 'ligand', 'receptor'))
  cellchat_count_group2 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group2]] %>% 
    select(c('target', 'ligand', 'receptor'))
  
  # Create interaction string without the target/receiver
  cellchat_count_group1$interaction <- paste(cellchat_count_group1$ligand, cellchat_count_group1$receptor, sep = '->')
  cellchat_count_group2$interaction <- paste(cellchat_count_group2$ligand, cellchat_count_group2$receptor, sep = '->')
  
  # Create a list of interactions for each receiver
  interaction_list1 <- split(cellchat_count_group1$interaction, cellchat_count_group1$target)
  interaction_list2 <- split(cellchat_count_group2$interaction, cellchat_count_group2$target)
  
  # Filter out sets with a list length of zero
  interaction_list1 <- interaction_list1[sapply(interaction_list1, length) > 0]
  interaction_list2 <- interaction_list2[sapply(interaction_list2, length) > 0]
  
  # Append group IDs to the set names
  names(interaction_list1) <- paste(names(interaction_list1), group1, sep = "_")
  names(interaction_list2) <- paste(names(interaction_list2), group2, sep = "_")
  
  # Combine the interaction lists
  combined_interaction_list <- c(interaction_list1, interaction_list2)
  
  # Create a combination matrix
  comb_mat_combined <- make_comb_mat(combined_interaction_list)
  
  # Filter out empty columns (those with no intersection size)
  non_empty_columns <- comb_degree(comb_mat_combined) > 0
  comb_mat_combined_filtered <- comb_mat_combined[, non_empty_columns]
  
  # Create a custom color vector based on the set combinations
  intersection_colors <- sapply(seq_len(ncol(comb_mat_combined_filtered)), function(i) {
    sets_in_comb <- rownames(comb_mat_combined_filtered)[comb_mat_combined_filtered[,i] == 1]
    r_sets <- sum(grepl("_R$", sets_in_comb))
    nr_sets <- sum(grepl("_NR$", sets_in_comb))
    
    if (r_sets > 0 && nr_sets == 0) {
      return("#B71C1C")  # Color for "_R" only
    } else if (nr_sets > 0 && r_sets == 0) {
      return('#2196F3')  # Color for "_NR" only
    } else if (r_sets > 0 && nr_sets > 0) {
      return("grey20")  # Color for both
    } else {
      return("grey50")  # Default color
    }
  })
  
  # Generate the UpSet plot
  tryCatch({
    grDevices::pdf(output_file, width = 6, height = 4)
    print(UpSet(comb_mat_combined_filtered, 
                pt_size = unit(5, "mm"), 
                lwd = 3, 
                comb_col = intersection_colors, 
                bg_col = c("grey90", "grey100"), 
                bg_pt_col = "grey70",
                set_order = desired_order))
  }, finally = {
    grDevices::dev.off()
  })
  
  # Check if the file was created successfully
  if (file.exists(output_file) && file.size(output_file) > 4096) {
    message("PDF file created successfully: ", output_file)
  } else {
    warning("PDF file creation may have failed or file is too small: ", output_file)
  }
  
  # Sanity check: Create a table of the number of interactions per set
  interactions_per_set <- sapply(combined_interaction_list, length)
  interactions_table <- data.frame(
    Set = names(interactions_per_set),
    Number_of_Interactions = interactions_per_set
  )
  
  # Sanity check: Get contributing interactions for each set
  contributing_interactions <- lapply(names(combined_interaction_list), function(set_name) {
    data.frame(
      Set = set_name,
      Interaction = combined_interaction_list[[set_name]]
    )
  })
  contributing_interactions <- do.call(rbind, contributing_interactions)
  
  # Sanity check: Get intersections and their sizes
  intersections <- comb_size(comb_mat_combined_filtered)
  intersection_sizes <- data.frame(
    Intersection = names(intersections),
    Size = intersections
  )
  
  # Create a list of returned objects
  returned_objects <- list(
    interactions_table = interactions_table,
    contributing_interactions = contributing_interactions,
    intersection_sizes = intersection_sizes,
    comb_mat = comb_mat_combined_filtered, 
    combined_interaction_list = combined_interaction_list
  )
  
  # Return the list of objects
  return(returned_objects)
}


# Example usage
original_receivers = c('IL7R_CD4', 'ITGAE_CD8', 'GZMK_CD8', 'NR4A2_CD8', 'CXCL13_Tcells', 'Tregs')

# Duplicate the vector and append "_R" and "_NR"
receivers_R <- paste(original_receivers, "_R", sep = "")
receivers_NR <- paste(original_receivers, "_NR", sep = "")

# Combine and rearrange the order
combined_receivers <- c(receivers_NR, receivers_R)

dc_post <- create_combined_upset_plot(cellchat = post.cellchat, 
                           sender = 'cDC1_CLEC9A',
                           target = unique(grep('CD4|CD8|Tcells|Tregs', post.cellchat@meta$consensus_clusters, value = T)), 
                           group1 = "NR", 
                           group2 = "R", 
                           desired_order = combined_receivers, 
                           output_file = "post_tx_cDC1_combined_UpsetPlot.pdf")
dc_pre <- create_combined_upset_plot(cellchat = pre.cellchat, 
                                        sender = 'cDC1_CLEC9A',
                                        target = unique(grep('CD4|CD8|Tcells|Tregs', pre.cellchat@meta$consensus_clusters, value = T)), 
                                        group1 = "NR", 
                                        group2 = "R", 
                                        desired_order = combined_receivers, 
                                        output_file = "pre_tx_cDC1_combined_UpsetPlot.pdf")
```

```{r S7A--Rank plots Complement (R/NR)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_complement/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
post <- merge(r_post, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 1 ~ "R_enriched",
  pre$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 1 ~ "R_enriched",
  post$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 9 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--pre-treatment
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  geom_point(data = pre, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Pre-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(pre, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_pretx_srlr_rankplot.pdf', width = 12, height = 8)
print(p)
dev.off()




# Create the base plot with all points--post-treatment

create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 12 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(post, aes(x = rank, y = log2FC)) +
  geom_point(data = post, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Post-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(post, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_post_tx_srlr_rankplot.pdf', width = 12, height = 8)
print(p)
dev.off()
```

```{r S4B--Rank plots Costim/Coinhib (R/NR)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_costim_coinhib/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
post <- merge(r_post, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 1 ~ "R_enriched",
  pre$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 1 ~ "R_enriched",
  post$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--pre-treatment
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  geom_point(data = pre, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/coinhibitory interactions only: Pre-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(pre, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coinhib_pretx_srlr_rankplot.pdf', width = 16, height = 8)
print(p)
dev.off()




# Create the base plot with all points--post-treatment

create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(post, aes(x = rank, y = log2FC)) +
  geom_point(data = post, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/coinhibitory interactions only: Post-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(post, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coinhib_post_tx_srlr_rankplot.pdf', width = 16, height = 8)
print(p)
dev.off()

```

```{r S7C--Rank plot Chemokine (Pre/Post paired) }
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('HNC_ICB_GolfinosOwens_etal_2025/CellChat_pairedonly/Luoma_cytokine/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
#nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
r <- merge(r_pre, r_post, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/R_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
nr <- merge(nr_pre, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(NR_pre_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
r$color_group <- case_when(
  r$log2FC > 1 ~ "PreTx_enriched",
  r$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)

nr$color_group <- case_when(
  nr$log2FC > 1 ~ "PreTx_enriched",
  nr$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 10 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--Responders
p <- ggplot(r, aes(x = rank, y = log2FC)) +
  geom_point(data = r, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Chemokine interactions only: Responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(Pre/Post Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(r, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Chemokine_paired_R_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()




# Create the base plot with all points--post-treatment

create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 9 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(nr, aes(x = rank, y = log2FC)) +
  geom_point(data = nr, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Chemokine interactions only: Non-responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(nr, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Chemokine_paired_NR_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()


```

```{r S7D--Rank plot Complement (Pre/Post paired)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(grid)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('HNC_ICB_GolfinosOwens_etal_2025/CellChat_pairedonly/Luoma_complement/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
#nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
r <- merge(r_pre, r_post, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/R_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
nr <- merge(nr_pre, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(NR_pre_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
r$color_group <- case_when(
  r$log2FC > 1 ~ "PreTx_enriched",
  r$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)

nr$color_group <- case_when(
  nr$log2FC > 1 ~ "PreTx_enriched",
  nr$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 9 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--Responders
p <- ggplot(r, aes(x = rank, y = log2FC)) +
  geom_point(data = r, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(Pre/Post Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(r, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_Paired_R_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()



# Create the base plot with all points--post-treatment
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 7 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   #'Mac_IL1B' = "#7BAFDE", 
                   'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 
                   #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(nr, aes(x = rank, y = log2FC)) +
  geom_point(data = nr, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Non-responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(nr, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_Paired_NR_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()

```

```{r S7E--Rank plot Costim/Coinhib (Pre/Post paired)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(grid)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('HNC_ICB_GolfinosOwens_etal_2025/CellChat_pairedonly/Luoma_costim_coinhib/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
#nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
r <- merge(r_pre, r_post, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/R_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
nr <- merge(nr_pre, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(NR_pre_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
r$color_group <- case_when(
  r$log2FC > 1 ~ "PreTx_enriched",
  r$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)

nr$color_group <- case_when(
  nr$log2FC > 1 ~ "PreTx_enriched",
  nr$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--Responders
p <- ggplot(r, aes(x = rank, y = log2FC)) +
  geom_point(data = r, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/Coinhibitory interactions only: Responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(Pre/Post Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(r, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coinhib_Paired_R_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()




# Create the base plot with all points--post-treatment
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(nr, aes(x = rank, y = log2FC)) +
  geom_point(data = nr, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/Coinhibitory interactions only: non-responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(nr, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coninhib_Paired_NR_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()

```

```{r S7F/G--DotPlots per neighborhood of LRs from 4C}
load("CosMX_TMA/CosMX_RNA_merged.rda")

CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20_anno == "Tumor_Immune_Mixed" ~ 'Tumor_Immune_Tcell_High',
      CosMX_RNA_merged$k10_NhCoord20_anno == "Macrophage_High" ~ "Immune_Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20_anno == "DC_T_iCAF_Tumor_Mixed" ~ "ap_iCAF_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20_anno == "CAF_Immune_Mixed" ~ "myCAF_Immune_Mixed",
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20_anno)
    ), col.name = "k10_NhCoord20_anno_new"
  )

 unique(CosMX_RNA_merged$k10_NhCoord20_anno_new)
#[1] "Bcell_Plasma"             "Endothelial"              "Tumor_Immune_Tcell_High" 
#[4] "ap_iCAF_Immune_Mixed"     "Immune_Macrophage_High"   "myCAF_Immune_Mixed"      
#[7] "CAFs"                     "Tumor_High"               "Myeloid_K17+_Tumor_Mixed"
 
immune_macrophage_high <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new == "Immune_Macrophage_High"]

p1 <- DotPlot(immune_macrophage_high[,grep('Mon|Mac|DC', immune_macrophage_high$annot_cluster2)], features = c('CXCL9', 'CXCL10', 'CXCL16', 'CCL5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

p2 <- DotPlot(immune_macrophage_high[,grep('CD4|CD8|Treg', immune_macrophage_high$annot_cluster2)], features = c('CXCR3', 'CXCR6', 'CCR5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

pdf('immune_macrophage_high_NH_CXCL_CCL_dotplot_by_response.pdf', width = 14, height = 4)
cowplot::plot_grid(p1, p2)
dev.off()
 
 
 

tumor_immune_tcell_high <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new == "Tumor_Immune_Tcell_High"]

p1 <- DotPlot(tumor_immune_tcell_high[,grep('Mon|Mac|DC', tumor_immune_tcell_high$annot_cluster2)], features = c('CXCL9', 'CXCL10', 'CXCL16', 'CCL5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

p2 <- DotPlot(tumor_immune_tcell_high[,grep('CD4|CD8|Treg', tumor_immune_tcell_high$annot_cluster2)], features = c('CXCR3', 'CXCR6', 'CCR5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

pdf('tumor_immune_tcell_high_NH_CXCL_CCL_dotplot_by_response.pdf', width = 14, height = 4)
cowplot::plot_grid(p1, p2)
dev.off()
```

```{r S5A--Full labeled rank plot}
source('HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/Scripts/LR_Rank_Functions.R')

# Load in list from calculation step and merge them into a single dataframe
resultList <- readRDS(file = 'HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/LR_boxplots/SCDC_LR_Comparison.rds')
allSamples <- do.call(rbind, args = resultList)
allSamples$score <- as.numeric(allSamples$score)

chemokineInteractions <- read.csv('HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/ChemokineInteractions.csv')

# Filter to LR interactions with more than 2 samples per response group
result <- allSamples %>% 
  filter(sample_id != 'ck17_209') %>%
  group_by(LR_pair, response) %>%
  summarise(
    sample_count = n(),
    mean_value = mean(score),
    .groups = 'drop'
  ) %>%
  filter(sample_count >= 2) %>% 
  group_by(LR_pair) %>% 
  filter(n() == 2) %>%
  summarise(mean_diff = (diff(mean_value)), .groups = 'drop') %>%
  arrange(desc(mean_diff))

rankplot <- result %>% 
  mutate(rank = rank(-mean_diff)) %>%  # Create rank based on mean_diff
  mutate(label_category = case_when(
    rank <= 10 ~ "top",
    rank > (n() - 10) ~ "bottom",
    TRUE ~ "middle"
  )) %>%
  mutate(label = ifelse(label_category != "middle", LR_pair, ''))

ggplot(data = rankplot, 
       aes(x = rank, y = mean_diff, 
           label = label,
           color = label_category,
           size = label_category,
           alpha = label_category)) + 
  # Plot grey dots first
  geom_point(data = subset(rankplot, label_category == "middle")) +
  # Plot colored dots second
  geom_point(data = subset(rankplot, label_category != "middle")) +
  scale_color_manual(values = c("top" = "red", "bottom" = "blue", "middle" = "grey")) +
  scale_size_manual(values = c("top" = 3, "bottom" = 3, "middle" = 2)) +
  scale_alpha_manual(values = c("top" = 1, "bottom" = 1, "middle" = 0.5)) +
  xlab('Ligand-Receptor Rank (Mean R vs NR Difference)') + 
  ylab('R-NR LR Mean CD45+ Spot Proportion') + 
  ggtitle('Mean Difference of CD45+ Spot LR Proportions (R-NR)') + 
  theme_classic() +
  # Plot labels last with increased repulsion
  geom_text_repel(data = subset(rankplot, label_category != "middle"), 
                  max.overlaps = Inf, 
                  show.legend = FALSE, 
                  force = 10,
                  nudge_x = 0.05,
                  nudge_y = 0.05,
                  direction = 'both',
                  box.padding = 0.5,
                  point.padding = 0.5,
                  segment.color = 'grey50') +
  theme_prism(base_size = 20) +
  theme(legend.position = "none")

ggsave('allInts_SCDC_LR_rank_mean_difference_top_bottom.pdf', width = 12, height = 8)
```

```{r S5B/C--Highlighted R- and NR-enriched interactions from S5A}
source('HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/Scripts/LR_Rank_Functions.R')

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

#Load in list from calculation step and merge them into a single dataframe
resultList<-readRDS(file = 'HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/LR_boxplots/SCDC_LR_Comparison.rds')
allSamples<-do.call(rbind,args = resultList)
allSamples$score=as.numeric(allSamples$score)



library(ggplot2)
library(dplyr)
library(ggpubr)
library(cowplot)

# Function to create the plot
create_lr_plot <- function(allSamples, lr_pairs) {
  # Create LR_pair column
  lr_pairs_combined <- sapply(lr_pairs, function(pair) paste(pair[1], pair[2], sep="_"))
  
  # Filter data
  plot_data <- allSamples %>%
    filter(LR_pair %in% lr_pairs_combined, sample_id != 'ck17_209')
  
  # Create the plot
  g <- ggplot(data = plot_data, 
              aes(x = response, y = score, fill = response, color = response)) + 
    geom_boxplot(alpha = 0.5, outlier.size = 0) + 
    geom_jitter(alpha = 0.8) + 
    stat_compare_means() + 
    facet_wrap(~LR_pair, scales = "free_y") +
    theme_bw() +
    theme(axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(), 
          axis.title.x = element_blank(), 
          strip.text = element_text(size = 12),
          legend.key.size = unit(1, 'cm'), 
          legend.title = element_text(size = 30), 
          legend.text = element_text(size = 20), 
          axis.text = element_text(size = 16),
          axis.title = element_text(size = 12), 
          legend.position = 'none') + 
    scale_shape_manual(values = 1:5) + 
    scale_fill_manual(name = 'ICB\nResponse', values = c('#2196F3', '#FF8A80')) +
    scale_color_manual(values = c('#2196F3', '#FF8A80')) +
    ylab('Proportion of LR spots among CD45+ spots') +
    xlab('ICB Response')
  
  return(g)
}

lr_pairs_r <- list(c('EFNB1', 'EHA4'), c('NRG1', 'ERBB3'), c('EFNA1', 'EPHA4'), c('SEMA6D', 'PLXNA1'), c('HLA-DQA1', 'CD4'), c('CXCL11', 'ACKR3'), c('DLL1', 'NOTCH1'), c('ENTPD1', 'ADORA2B'), c('TNF', 'TNFRSF1A'), c('GZMA', 'PARD3'))
plot_r <- create_lr_plot(allSamples, lr_pairs_r)

# Save the plot
pdf('R_LR_prop_CD45pos_spots.pdf', width = 7, height = 8)
print(plot_r)
dev.off()



lr_pairs_nr <- list(c('CXCL5', 'ACKR1'), c('CCL13', 'CCR1'), c('CADM3', 'CADM3'), c('CXCL2', 'ACKR1'), c('CCL13', 'ACKR1'), c('CXCL3', 'ACKR1'), c('CSF3', 'CSF3R'), c('CNTN1', 'NRCAM'), c('EREG', 'EGFR'), c('NECTIN1', 'CADM3'))
plot_nr <- create_lr_plot(allSamples, lr_pairs_nr)

# Save the plot
pdf('NR_LR_prop_CD45pos_spots.pdf', width = 8, height = 8)
print(plot_nr)
dev.off()

```

```{r S8--ligand and receptor heatmaps (Fig 3A highlights)}
library(pheatmap)
library(RColorBrewer)
library(edgeR)

# Load annotation data
ann_cd45 <- readxl::read_excel('/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/inputs/GSE226134_CD45_10__norm (1).xlsx')
ann_cd68 <- readxl::read_excel('/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/inputs/GSE226134_CD68_10__norm.xlsx')
ann_ck <- readxl::read_excel('/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/inputs/GSE226134_CK_10__norm.xlsx')

# Load GeoMx data
t <- readRDS("/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/NanoStringGeoMxSet_objects/raw_Yale_geomx.RDS")
e <- exprs(t)
log <- log2(e+1)
test <- fData(t)

lr_pairs <- list(
  #c('CXCL9', 'CXCR3'),
  #c('CXCL10', 'CXCR3'),
  #c('CXCL16', 'CXCR6'),
  c('CCL5', 'CCR5'),
  c('IL16', 'CD4'),
  c('IL11', 'IL11RA'),
  c('CCL19', 'CCR7'),
  c('CCL21', 'CCR7'),
  c('CCL4', 'CCR5'),
  c('CCL3', 'CCR5'),
  c('CCL13', 'CCR1'),
  c('CCL3', 'CCR1'),
  c('CCL2', 'CCR2'),
  c('CCL8', 'CCR1'),
  c('CCL8', 'CCR2'),
  c('CXCL12', 'CXCR4'),
  c('IL1B', 'IL1R2'),
  c('IL1B', 'IL1R1'),
  c('IL1A', 'IL1R2'),
  c('CCL5', 'CCR1'),
  c('CCL15', 'CCR1')
)

# Function to prepare data for heatmap
prepare_heatmap_data <- function(geomx_data, gene_list, segment) {
  e <- exprs(geomx_data)
  log_data <- cpm(e, log = T)
  log_data <- scale(log_data)
  test_data <- fData(geomx_data)
  test2 <- pData(geomx_data)
  
  # Replace RTS_IDs with TargetNames
  rownames(log_data) <- test_data$TargetName[match(rownames(log_data), test_data$RTS_ID)]
  
  # Filter for specified segment
  segment_data <- test2[grepl(segment, test2$segment), ]
  
  # Subset expression data for the segment and specified genes
  gene_list <- intersect(gene_list, rownames(log_data))

  heatmap_data <- log_data[gene_list, rownames(segment_data)]
  
  
  # Transpose so that genes are rows and samples are columns
  heatmap_data <- t(heatmap_data)
  
  return(list(data = heatmap_data, metadata = segment_data))
}





# Extract ligands and receptors from lr_pairs
ligands <- unique(sapply(lr_pairs, `[`, 1))
receptors <- sapply(lr_pairs, `[`, 2)

# Prepare data for CD68 (ligands) heatmap
cd68_data <- prepare_heatmap_data(geomx_data = t, gene_list = ligands, segment = "Segment 1")

# Prepare data for CD45 (receptors) heatmap
cd45_data <- prepare_heatmap_data(t, receptors, "Segment 2")

# Create annotation data frame for CLINICAL_BENEFIT
annotation_df <- data.frame(CLINICAL_BENEFIT = cd68_data$metadata$CLINICAL_BENEFIT)
rownames(annotation_df) <- rownames(cd68_data$metadata)

library(ComplexHeatmap)
library(circlize)

# Create color scales
expr_colors <- colorRamp2(c(min(cd68_data$data), mean(cd68_data$data), max(cd68_data$data)), 
                          c("blue", "white", "red"))

anno_colors <- list(CLINICAL_BENEFIT = c("YES" = "red", "NO" = "blue"))

# Create annotation object
column_ha <- HeatmapAnnotation(
  CLINICAL_BENEFIT = annotation_df$CLINICAL_BENEFIT,
  col = anno_colors
)

cd68_data$data <- t(cd68_data$data)
cd45_data$data <- t(cd45_data$data)

annotation_df_cd45 <- data.frame(CLINICAL_BENEFIT = cd45_data$metadata$CLINICAL_BENEFIT)
rownames(annotation_df_cd45) <- rownames(cd45_data$metadata)

column_ha_cd45 <- HeatmapAnnotation(
  CLINICAL_BENEFIT = annotation_df_cd45$CLINICAL_BENEFIT,
  col = anno_colors
)

# Create CD68 (ligands) heatmap
cd68_heatmap <- Heatmap(cd68_data$data,
                        name = "Expression",
                        column_title = "CD68 Ligands Heatmap",
                        col = expr_colors,
                        top_annotation = column_ha,
                        show_column_names = FALSE,
                        show_row_names = TRUE,
                        cluster_rows = TRUE,
                        cluster_columns = FALSE,
                        column_split = annotation_df$CLINICAL_BENEFIT,
                        column_title_gp = gpar(fontsize = 14, fontface = "bold"))


# Create CD45 (receptors) heatmap
cd45_heatmap <- Heatmap(cd45_data$data,
                        name = "Expression",
                        column_title = "CD45 Receptors Heatmap",
                        col = expr_colors,
                        top_annotation = column_ha_cd45,
                        show_column_names = FALSE,
                        show_row_names = TRUE,
                        cluster_rows = TRUE,
                        cluster_columns = FALSE,
                        column_split = annotation_df_cd45$CLINICAL_BENEFIT,
                        column_title_gp = gpar(fontsize = 14, fontface = "bold"))

# Draw and save the heatmaps
pdf("CD68_ligands_heatmap.pdf", width = 10, height = 8)
draw(cd68_heatmap)
dev.off()

pdf("CD45_receptors_heatmap.pdf", width = 10, height = 8)
draw(cd45_heatmap)
dev.off()


```

