---
title: "HNC Supplemental Figures"
author: "Athena Golfinos-Owens"
date: "2025-02-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(DescTools)
library(Seurat)
library(tidyr)
library(ComplexHeatmap)
library(circlize)
library(ggplot2)
library(cowplot)
library(ggpmisc)
library(ggpubr)
library(ggprism)
library(grid)

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 
print(getwd())
```

```{r Metadata add: Preparation for Cell Composition Heatmap--CosMx RNA Neighborhood Coordination}
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

rna_k10 <- read.csv('/Volumes/hqdinh2/Projects/HNC_SPORE/NeighborhoodCoordination/CosMx_RNA/Neighborhood_Coordination_CosMxRNA/WindowSize10/cells20neighborhoods.csv', row.names = 1) %>% 
  select(c('neighborhood10'))
colnames(rna_k10) <- 'k10_NhCoord20'

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

CosMX_RNA_merged <- AddMetaData(CosMX_RNA_merged, metadata = rna_k10)

CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20 %in% c('9') ~ 'Myeloid_K17+_Tumor_Mixed',
      CosMX_RNA_merged$k10_NhCoord20 %in% c('12') ~ "Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('8', '17') ~ "Tumor_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('5') ~ "DC_T_iCAF_Tumor_Mixed",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('10') ~ 'CAF_Immune_Mixed',
      CosMX_RNA_merged$k10_NhCoord20 %in% c('19') ~ "Endothelial",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('16', '18') ~ "CAFs",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('3', '15') ~ "Bcell_Plasma",
      CosMX_RNA_merged$k10_NhCoord20 %in% c('4', '7', '0', '13', '6', '1', '11', '2', '14') ~ 'Tumor_High',
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20)
    ),
    col.name = "k10_NhCoord20_anno"
  )

table(CosMX_RNA_merged$k10_NhCoord20_anno)
#            Bcell_Plasma                     CAFs    DC_T_iCAF_Tumor_Mixed              Endothelial          Macrophage_High Myeloid_K17+_Tumor_Mixed               Tumor_High 
#                   22398                    15427                    23634                     5995                     9422                    14217                   133021 
#      Tumor_Immune_Mixed 
#                   25680 

save(CosMX_RNA_merged, file = '/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda')
```

```{r S1A--CosMx protein cell type frequency}

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", 
                    "#FF7F00", "#FDB462", "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", 
                    "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", 
                    "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# adding protein neighborhoods to the CosMx protein data
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/Protein-data/Analysis/CosMX_protein_annot_cluster.rda")

CosMx_Protein_log_norm$merged_annot_cluster <- factor(CosMx_Protein_log_norm$merged_annot_cluster, 
                            levels=c("Tumor_cells",
                                     "Fibroblasts/SMCs", 
                                     "Endothelial_cells", 
                                     "Plasma_cells", 
                                     "B_cells",
                                     "Tregs", 
                                     "CD8+T_cells", 
                                     "CD4+T_cells", 
                                     "NK_cells", 
                                     "Neutrophils", 
                                     "DCs", 
                                     "Macrophages", 
                                     "Monocytes"))
Idents(CosMx_Protein_log_norm) <- 'merged_annot_cluster'

# Step 1: Create a named vector for cluster order
cluster_order <- c(
  "Tumor_cells" = "1",
  "Fibroblasts/SMCs" = "2",
  "Endothelial_cells" = "3",
  "Plasma_cells" = "4",
  "B_cells" = "5",
  "Tregs" = "6",
  "CD8+T_cells" = "7",
  "CD4+T_cells" = "8",
  "NK_cells" = "9",
  "Neutrophils" = "10",
  "DCs" = "11",
  "Macrophages" = "12",
  "Monocytes" = "13"
)

# Step 2: Create a custom labeller function
custom_labeller <- function(variable, value) {
  return(names(cluster_order)[match(value, cluster_order)])
}


# plotting cell type frequency 
freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  SEU$orig.ident <- SEU[[c('tma_fov_id')]]
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs),]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
    # Define the custom order for clusters
    cluster_order <- c(
      "Tumor_cells" = "Tumor_cells",
      "Fibroblasts/SMCs" = "Fibroblasts/SMCs",
      "Endothelial_cells" = "Endothelial_cells",
      "Plasma_cells" = "Plasma_cells",
      "B_cells" = "B_cells",
      "Tregs" = "Tregs",
      "CD8+T_cells" = "CD8+T_cells",
      "CD4+T_cells" = "CD4+T_cells",
      "NK_cells" = "NK_cells",
      "Neutrophils" = "Neutrophils",
      "DCs" = "DCs",
      "Macrophages" = "Macrophages",
      "Monocytes" = "Monocytes"
    )
    
    # Convert Cluster to factor with custom order
    #df$Cluster <- factor(df$Cluster, levels = names(cluster_order))
    
    ggplot(df) +
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), 
                   position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), 
                 alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 3, ncol = 5,
                 #labeller = as_labeller(cluster_order)
                 ) + 
      theme_bw() + 
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(), 
            axis.title.x = element_blank(), 
            strip.text = element_text(size = 12)) + 
      scale_shape_manual(values = 1:5) + 
      theme(legend.key.size = unit(1, 'cm'), 
            legend.title = element_text(size=30), 
            legend.text = element_text(size=20), 
            axis.text = element_text(size=16),
            axis.title = element_text(size=30), 
            legend.position = 'none') + 
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      labs(y = "Cell Type Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), 
           width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

test <- freq_plot(SEU = CosMx_Protein_log_norm, 
                  metadata = 'merged_annot_cluster', 
                  split.meta = 'Response', 
                  graph_type = 'freq_boxplot', 
                  out = 'CosMx_protein_', 
                  out_width = 10.5, 
                  out_height = 6, 
                  out_units = 'in', 
                  out_res = 300, 
                  test_by_group = TRUE)
```

```{r S1B--CosMx RNA KRT genes Dotplot}
# plotting the keratin genes in the RNA data
load('/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda')

DotPlot(CosMX_RNA_merged[,CosMX_RNA_merged$annot_cluster2 %in% c('Tumors_Others', 'Tumors_KRT19+',
                                                                 'Tumors_KRT17+', 'Tumors_HIF1A+')], 
        features = grep('^KRT', rownames(CosMX_RNA_merged), value = T), 
        group.by = 'annot_cluster2', col.min = 0) + 
  #coord_flip() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
ggsave('CosMx_RNA_KRT_genes_dotplot.pdf', width = 7, height = 4)
```

```{r S1C--CosMx RNA cell type frequency}
load('/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda')

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", 
                    "#FF7F00", "#FDB462", "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", 
                    "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", "#7570B3", "#BEAED4", 
                    "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

CosMX_RNA_merged$annot_cluster2[grep('inflammatory', CosMX_RNA_merged$annot_cluster2)] <- 'Fibroblast_VEGFA_iCAFs'
CosMX_RNA_merged$annot_cluster2 <- gsub("Fibroblast", "Fib", CosMX_RNA_merged$annot_cluster2)


freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  SEU$orig.ident <- SEU[[c('tma_fov_id')]]
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs),]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
    # Define the custom order for clusters
    cluster_order <- c(
      "Tumors_HIF1A+" = "Tumors_HIF1A+",
      "Tumors_KRT17+" = "Tumors_KRT17+",
      "Tumors_KRT19+" = "Tumors_KRT19+",
      "Tumors_Others" = "Tumors_Others",
      "Fib_apCAFs" = "Fib_apCAFs",
      "Fib_myCAFs" = "Fib_myCAFs",
      "Fib_VEGFA_iCAFs" = "Fib_VEGFA_iCAFs",
      "Endothelials" = "Endothelials",
      "Bcells" = "Bcells",
      "Plasma" = "Plasma",
      "Tcells_CD4+" = "Tcells_CD4+",
      "TcellsCD8+" = "TcellsCD8+",
      "Tregs" = "Tregs",
      'DCs' = 'DCs',
      'Macrophages' = 'Macrophages',
      'Monocytes' = 'Monocytes'
    )
    
    # Convert Cluster to factor with custom order
    df$Cluster <- factor(df$Cluster, levels = names(cluster_order))
    
    ggplot(df) +
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), 
                   position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), 
                 alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 3, ncol = 6,
                 labeller = as_labeller(cluster_order)) + 
      theme_bw() + 
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(), 
            axis.title.x = element_blank(), 
            strip.text = element_text(size = 12)) + 
      scale_shape_manual(values = 1:5) + 
      theme(legend.key.size = unit(1, 'cm'), 
            legend.title = element_text(size=30), 
            legend.text = element_text(size=20), 
            axis.text = element_text(size=16),
            axis.title = element_text(size=30), 
            legend.position = 'none') + 
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      labs(y = "Cell Type Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), 
           width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

test <- freq_plot(SEU = CosMX_RNA_merged, 
                  metadata = 'annot_cluster2', 
                  split.meta = 'Response', 
                  graph_type = 'freq_boxplot', 
                  out = 'CosMx_RNA_', 
                  out_width = 12.5, 
                  out_height = 7, 
                  out_units = 'in', 
                  out_res = 300, 
                  test_by_group = TRUE)
```

```{r S1D--CosMx protein/RNA cell type freq correlation}
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/Protein-data/Analysis/CosMX_protein_annot_cluster.rda")

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3", "#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

meta_rna <- as.data.frame(table(CosMX_RNA_merged$annot_cluster2, CosMX_RNA_merged$tma_fov_id))
meta_protein <- as.data.frame(table(CosMx_Protein_log_norm$merged_annot_cluster, CosMx_Protein_log_norm$tma_fov_id))

# calculate percentages by FOV for the RNA FOVs
# Step 2: Group by sample (Var2) and calculate percentages
meta_rna_percentages <- meta_rna %>%
  group_by(Var2) %>%
  mutate(Percentage = Freq / sum(Freq) * 100) %>%
  ungroup()
# Step 3: Round the percentages to two decimal places (optional)
meta_rna_percentages$Percentage <- round(meta_rna_percentages$Percentage, 2)
# Step 4: View the first few rows of the new dataframe
head(meta_rna_percentages)
# Sanity check
sanity_check <- meta_rna_percentages %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
# View the results
print(sanity_check)
# Check if all samples sum to approximately 100%
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
# If not all correct, view the problematic samples
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}






# calculate percentages by FOV for the protein FOVs
# Step 2: Group by sample (Var2) and calculate percentages
meta_protein_percentages <- meta_protein %>%
  group_by(Var2) %>%
  mutate(Percentage = Freq / sum(Freq) * 100) %>%
  ungroup()
# Step 3: Round the percentages to two decimal places (optional)
meta_protein_percentages$Percentage <- round(meta_protein_percentages$Percentage, 2)
# Step 4: View the first few rows of the new dataframe
head(meta_protein_percentages)
# Sanity check
sanity_check <- meta_protein_percentages %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
# View the results
print(sanity_check)
# Check if all samples sum to approximately 100%
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
# If not all correct, view the problematic samples
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}




unique(meta_rna_percentages$Var1)
# [1] Bcells                                 DCs                                    Endothelials                           Fibroblast_apCAFs                     
# [5] Fibroblast_myCAFs                      Fibroblast_VEGFA_inflammatorylike_CAFs Macrophages                            Monocytes                             
# [9] Plasma                                 Tcells_CD4+                            TcellsCD8+                             Tregs                                 
# [13] Tumors_HIF1A+                          Tumors_KRT17+                          Tumors_KRT19+                          Tumors_Others 
unique(meta_protein_percentages$Var1)
# [1] B_cells           CD4+T_cells       CD8+T_cells       DCs               Endothelial_cells Fibroblasts/SMCs  Macrophages       Monocytes         Neutrophils       NK_cells         
# [11] Plasma_cells      Tregs             Tumor_cells     





library(stringr)

# Create a new column for the broader categories
meta_rna_aggregated <- meta_rna_percentages %>%
  mutate(
    Broad_Category = case_when(
      str_starts(Var1, "Tumors") ~ "Tumor_cells",
      str_starts(Var1, "Fibroblast") ~ "Fibroblasts/SMCs",
      TRUE ~ as.character(Var1)  # Keep other categories as they are
    )
  )
# Aggregate the percentages for the broader categories
meta_rna_aggregated <- meta_rna_aggregated %>%
  group_by(Var2, Broad_Category) %>%
  summarize(
    Aggregated_Percentage = sum(Percentage),
    .groups = "drop"
  ) %>%
  rename(Var1 = Broad_Category)
# Round the aggregated percentages to two decimal places
meta_rna_aggregated$Aggregated_Percentage <- round(meta_rna_aggregated$Aggregated_Percentage, 2)
# View the first few rows of the new dataframe
head(meta_rna_aggregated)
# Perform a sanity check on the aggregated data
sanity_check <- meta_rna_aggregated %>%
  group_by(Var2) %>%
  summarize(
    Total_Percentage = sum(Aggregated_Percentage),
    Is_100 = abs(Total_Percentage - 100) < 0.05
  ) %>%
  ungroup()
print(sanity_check)
all_correct <- all(sanity_check$Is_100)
cat("All samples sum to 100% (within rounding error):", all_correct, "\n")
if (!all_correct) {
  cat("Samples not summing to 100% (within rounding error):\n")
  print(sanity_check[!sanity_check$Is_100, ])
}







meta_rna_aggregated <- meta_rna_aggregated %>%
  mutate(Var1 = case_when(
    Var1 == "Bcells" ~ "B_cells",
    Var1 == "Endothelials" ~ "Endothelial_cells",
    Var1 == "Plasma" ~ "Plasma_cells",
    Var1 == "Tcells_CD4+" ~ "CD4+T_cells",
    Var1 == "TcellsCD8+" ~ "CD8+T_cells",
    TRUE ~ as.character(Var1)  # Keep other categories as they are
  ))
# View the first few rows to check the changes
head(meta_rna_aggregated)
# Optional: Check unique values in Var1 to ensure all changes were made
unique(meta_rna_aggregated$Var1)
# look at the overlap between the dataset labels
intersect(meta_rna_aggregated$Var1, meta_protein_percentages$Var1)
# remove cell types not present in both groups so it is equal
meta_protein_percentages_mini <- meta_protein_percentages[grep('NK_cells|Neutrophils', meta_protein_percentages$Var1, invert = T), c('Var1', 'Var2', 'Percentage')]
# making a "group" column to merge by
meta_rna_aggregated$group <- paste(meta_rna_aggregated$Var1, meta_rna_aggregated$Var2, sep = ':')
meta_protein_percentages_mini$group <- paste(meta_protein_percentages_mini$Var1, meta_protein_percentages_mini$Var2, sep = ':')
# merge both RNa and protein data together
all_data <- merge(meta_rna_aggregated, meta_protein_percentages_mini, by = 'group')






ggplot(all_data, aes(x=Aggregated_Percentage, y=Percentage, color = Var1.x)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "grey", linetype = "dashed") +
  stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")), 
               formula = y ~ x, parse = TRUE, color = "black") +
  theme_classic() + 
  xlab('Cell Type Percentage by FOV in CosMx RNA data') + 
  ylab('Cell Type Percentage by FOV in CosMx Protein data') +
  scale_color_manual(values = color_clusters) +
  labs(color = "Cell Type") +
  ggtitle('Cell type frequency per FOV by dataset') +
  theme(
    axis.title = element_text(size = 16, face = "bold"),  # Larger axis labels
    axis.text = element_text(size = 14),  # Larger axis text
    legend.title = element_text(size = 14, face = "bold"),  # Larger legend title
    legend.text = element_text(size = 12),  # Larger legend text
    legend.key.size = unit(1, "cm"),  # Larger legend keys
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)  # Larger, centered title
  )

ggsave('cosmx_celltypecomparison_scatterplot.pdf', dpi = 900, width = 9, height = 6)

```

```{r S1E--SCDC Broad cell type boxplot from Visium}
scdc <- read.csv('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/SCDC_compartment_proportions.csv') %>% 
  select(c(Cell_Type, Proportion, Sample_Name, Response))

scdc <- scdc %>%
  group_by(Cell_Type, Sample_Name) %>%
  summarise(Proportion = mean(Proportion),
            Response = first(Response),
            .groups = "drop")

# First, calculate the sum of proportions for each Sample_Name
sample_totals <- scdc %>%
  group_by(Sample_Name) %>%
  summarise(Total = sum(Proportion))

# Create the "Others" category
others <- scdc %>%
  group_by(Sample_Name) %>%
  summarise(
    Cell_Type = "Others",
    Proportion = 1 - sum(Proportion),
    Response = first(Response)
  )

# Combine the original data with the "Others" category
scdc_with_others <- bind_rows(scdc, others)

# Reorder the rows to group by Sample_Name
scdc_with_others <- scdc_with_others %>%
  arrange(Sample_Name, Cell_Type)

# plotting
g1 <- ggplot(scdc_with_others[!scdc_with_others$Sample_Name %in% c('ck17_209', 'ck17_21', 'ck17_27'),], aes(x = Response, y = Proportion, color = Response, fill = Response)) + 
  geom_boxplot(aes(x = Response, y = Proportion, color = Response, fill = Response), position = position_dodge(), alpha = 0.5, 
               outlier.color = NA) + 
  geom_point(aes(x = Response, y = Proportion, color = Response), alpha = 0.8, position = position_jitterdodge()) + 
  theme_bw() + 
  facet_grid(~Cell_Type) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), 
        strip.text = element_text(size = 12)) + 
  scale_color_manual(values= c('#2196F3', '#FF8A80')) +
  scale_fill_manual(values = c('#2196F3', '#FF8A80')) +
  ylab('Estimated cell type freq') +
  stat_compare_means() +
  theme(legend.key.size = unit(1, 'cm'), legend.title = element_text(size=30), legend.text = element_text(size=20),
        axis.text=element_text(size=16),axis.title=element_text(size=20), legend.position = 'none')

pdf('SCDC_boxplots.pdf', pointsize = 14, width = 8, height = 4)
g1
dev.off()

 
```

```{r S1F--Luoma frequency boxplot}
library(Seurat)
library(ggplot2)
library(dplyr)
library(DescTools)

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/objects/bill_luoma_consensus.rda')

luoma$consensus_clusters[luoma$consensus_clusters == c('Blood-like_CD14_Mono')] <- 'PBMC-like_CD14_Monocytes'

luoma@meta.data <- luoma@meta.data %>% mutate(consensus_clusters = case_when(consensus_clusters == c('Blood-like_CD14_Monoc') ~ 'PBMC-like_CD14_Monocytes'))

freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  SEU$orig.ident <- SEU[[c('Patient_ID')]]
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs),]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
  
    
    ggplot(df) +
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), 
                   position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), 
                 alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 4, ncol = 6,
                 #labeller = as_labeller(cluster_order)
      ) + 
      theme_bw() + 
      theme(axis.text.x = element_blank(), 
            axis.ticks.x = element_blank(), 
            axis.title.x = element_blank(), 
            strip.text = element_text(size = 12)) + 
      scale_shape_manual(values = 1:5) + 
      theme(legend.key.size = unit(1, 'cm'), 
            legend.title = element_text(size=30), 
            legend.text = element_text(size=20), 
            axis.text = element_text(size=16),
            axis.title = element_text(size=30), 
            legend.position = 'none') + 
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      labs(y = "Cell Type Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), 
           width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

test <- freq_plot(SEU = luoma, 
                  metadata = 'consensus_clusters', 
                  split.meta = 'response_binary', 
                  graph_type = 'freq_boxplot', 
                  out = 'luoma_', 
                  out_width = 18, 
                  out_height = 8, 
                  out_units = 'in', 
                  out_res = 300, 
                  test_by_group = TRUE)
```

```{r S1G--scGOclust myeloid cells Cillo Luoma}
# comparing Cillo object and our gene sigs with Luoma object and our gene sigs
library(Seurat)
library(pheatmap)
library(httr)
library(scGOclust)
library(ComplexHeatmap)
library(tibble)
library(dplyr)

# load in seurat objects
load('/Volumes/hqdinh2/Lab Manuscripts/HNC_ICB_GolfinosOwens_etal_2025/objects/bill_luoma_consensus.rda')
load('/Volumes/hqdinh2/Projects/HNC_SPORE/Seurat_Objs/HNC_human/cillo_all_cells.rda') # called hnc2


# confiiguring ensembl due to expired certificates
httr::set_config(httr::config(ssl_verifypeer = FALSE)) 
hs_tbl = ensemblToGo(species = 'hsapiens', GO_linkage_type = c('experimental', 'phylogenetic', 'computational', 'author', 'curator')) # get biological process GO terms
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())


# generating mini objects with just myeloid cells
luoma_mini <- luoma[,grep('DC|Mono|Mac', luoma$consensus_clusters)]
cillo_mini <- hnc2[,grep('DC|Mono|Mac', hnc2$global.cluster4)]
cillo_mini <- cillo_mini[,grep('TIL', cillo_mini$tissue)]

# getting metadata for luoma and Cillo myeloid cells
luoma_meta <- luoma_mini[[c('consensus_clusters', 'subset_CellType_ID', 'nCount_RNA', 'nFeature_RNA', 'response_binary')]]
cillo_meta <- cillo_mini[[c('global.cluster4', 'nCount_RNA', 'nFeature_RNA')]]

# creating the gene ontology seurat objects
luoma_go_obj <- makeGOSeurat(ensembl_to_GO = hs_tbl, feature_type = 'external_gene_name', seurat_obj = luoma_mini)
cillo_go_obj <- makeGOSeurat(ensembl_to_GO = hs_tbl, feature_type = 'external_gene_name', seurat_obj = cillo_mini)

# provide the cell type metadata so we can compare the labels
luoma_ct_go <- getCellTypeGO(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters')
cillo_ct_go <- getCellTypeGO(go_seurat_obj = cillo_go_obj, cell_type_col = 'global.cluster4')

# heatmap of Pearson's correlation coefficient of cell type average BP profiles within species
luoma_corr1 = cellTypeGOCorr(cell_type_go = luoma_ct_go, corr_method = 'pearson')
pheatmap(luoma_corr1)
cillo_corr1 = cellTypeGOCorr(cell_type_go = cillo_ct_go, corr_method = 'pearson')
pheatmap(cillo_corr1)

# analyze the cell-by-GO BP profile as a count matrix
luoma_go_analyzed = analyzeGOSeurat(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters', min.dist = 0.3, spread = 0.5)
cillo_go_analyzed = analyzeGOSeurat(go_seurat_obj = cillo_go_obj, cell_type_col = 'global.cluster4', min.dist = 0.3, spread = 0.5)


## calculation takes a few minutes due to the Wilcox signed rank test
ct_shared_go = scGOclust::getCellTypeSharedGO(species_1 = 'hsapiens', species_2 = 'hsapiens', analyzed_go_seurat_sp1 = luoma_go_analyzed, 
                                              analyzed_go_seurat_sp2 = cillo_go_analyzed, cell_type_col_sp1 = 'consensus_clusters', 
                                              cell_type_col_sp2 = 'global.cluster4', layer_use = 'data')
head(ct_shared_go$shared_sig_markers)

corr = crossSpeciesCellTypeGOCorr(species_1 = 'hsapiens', species_2 = 'hsapiens', cell_type_go_sp1 = luoma_ct_go, cell_type_go_sp2 = cillo_ct_go, corr_method = 'pearson')

rownames(corr) <- sapply(strsplit(rownames(corr),"_"), `[`, 2)
colnames(corr) <- sapply(strsplit(colnames(corr), '_'), `[`, 2)


pdf('CILLO_TUMOR_ONLY_myeloid_scGoclust_correlation_heatmap.pdf', width = 7, height = 6)
ComplexHeatmap::Heatmap(corr, border_gp = gpar(col = "black", lty = 1), column_title = 'Cillo et al (tumor only) myeloid cell subsets', 
                        column_title_side = 'bottom', row_title = 'Luoma et al myeloid cell subsets', 
                        row_title_side = 'right',  
                        cluster_columns = T, 
                        cluster_rows = T, 
                        heatmap_legend_param = list(
                          title = "Pearson correlation", title_position = 'leftcenter-rot'))
dev.off()
```

```{r S1H--scGOclust T cells Cillo Luoma}
# luoma-Cillo myeloid cell subtype comparison
library(Seurat)
library(pheatmap)
library(httr)
library(scGOclust)
library(ComplexHeatmap)
library(tibble)
library(dplyr)

# load in seurat objects
load('/Volumes/hqdinh2/Lab Manuscripts/HNC_ICB_GolfinosOwens_etal_2025/objects/bill_luoma_consensus.rda')

# confiiguring ensembl due to expired certificates
httr::set_config(httr::config(ssl_verifypeer = FALSE)) 
hs_tbl = ensemblToGo(species = 'hsapiens', GO_linkage_type = c('experimental', 'phylogenetic', 'computational', 'author', 'curator')) # get biological process GO terms
setwd('/Volumes/hqdinh2/Lab Manuscripts/HNC_ICB_GolfinosOwens_etal_2025/scGOclust/cillo_luoma_consensus_clusters/')

# generating mini objects with just myeloid cells
luoma_mini <- luoma[,grep('CD4|CD8|Treg|Tcells', luoma$consensus_clusters)]

# getting metadata for luoma and luoma T cells
luoma_meta <- luoma_mini[[c('consensus_clusters', 'subset_CellType_ID', 'nCount_RNA', 'nFeature_RNA', 'response_binary')]]

# creating the gene ontology seurat objects
luoma_go_obj <- makeGOSeurat(ensembl_to_GO = hs_tbl, feature_type = 'external_gene_name', seurat_obj = luoma_mini)

# provide the cell type metadata so we can compare the labels
luoma_ct_go_cillo <- getCellTypeGO(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters')
luoma_ct_go_luoma <- getCellTypeGO(go_seurat_obj = luoma_go_obj, cell_type_col = 'subset_CellType_ID')

# heatmap of Pearson's correlation coefficient of cell type average BP profiles within species
luoma_corr1 = cellTypeGOCorr(cell_type_go = luoma_ct_go_cillo, corr_method = 'pearson')
pheatmap(luoma_corr1)
luoma_corr2 = cellTypeGOCorr(cell_type_go = luoma_ct_go_luoma, corr_method = 'pearson')
pheatmap(luoma_corr2)

# analyze the cell-by-GO BP profile as a count matrix
luoma_go_analyzed_cillo = analyzeGOSeurat(go_seurat_obj = luoma_go_obj, cell_type_col = 'consensus_clusters', min.dist = 0.3, spread = 0.5)
luoma_go_analyzed_luoma = analyzeGOSeurat(go_seurat_obj = luoma_go_obj, cell_type_col = 'subset_CellType_ID', min.dist = 0.3, spread = 0.5)

# UMAP plot of the analyzed cell-by-GO BP profile, labeled by previously specified cell annotation column in meta.data
DimPlot(luoma_go_analyzed_cillo, label = TRUE) + NoLegend()
DimPlot(luoma_go_analyzed_luoma, label = TRUE) + NoLegend()

## calculation takes a few minutes due to the Wilcox signed rank test
ct_shared_go = scGOclust::getCellTypeSharedGO(species_1 = 'hsapiens', species_2 = 'hsapiens', analyzed_go_seurat_sp1 = luoma_go_analyzed_cillo, 
                                              analyzed_go_seurat_sp2 = luoma_go_analyzed_luoma, cell_type_col_sp1 = 'consensus_clusters', 
                                              cell_type_col_sp2 = 'subset_CellType_ID', layer_use = 'data')
head(ct_shared_go$shared_sig_markers)

corr = crossSpeciesCellTypeGOCorr(species_1 = 'hsapiens', species_2 = 'hsapiens', cell_type_go_sp1 = luoma_ct_go_cillo, cell_type_go_sp2 = luoma_ct_go_luoma, corr_method = 'pearson')

rownames(corr) <- sapply(strsplit(rownames(corr),"_"), `[`, 2)
colnames(corr) <- sapply(strsplit(colnames(corr), '_'), `[`, 2)

pdf('tcells_scGoclust_correlation_heatmap.pdf', width = 7, height = 6)
ComplexHeatmap::Heatmap(corr, border_gp = gpar(col = "black", lty = 1), column_title = 'Luoma et al T cell annotations', 
                        column_title_side = 'bottom', row_title = 'Cillo et al (reanalyzed) T cell annotations', 
                        row_title_side = 'right',  
                        cluster_columns = T, 
                        cluster_rows = T, 
                        heatmap_legend_param = list(
                          title = "Pearson correlation", title_position = 'leftcenter-rot'))
dev.off()
```

```{r S2A--protein neighborhood heatmap (20 clusters)}
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/Protein-data/Analysis/CosMX_protein_annot_cluster.rda")

# Create a table of cell counts
cell_counts <- CosMx_Protein_log_norm@meta.data %>%
  group_by(NhCoord20, merged_annot_cluster) %>%
  summarise(count = n()) %>%
  spread(merged_annot_cluster, count, fill = 0)

# Convert NhCoord20_anno to row names and remove it as a column
cell_counts_matrix <- as.matrix(cell_counts[,-1])
rownames(cell_counts_matrix) <- cell_counts$NhCoord20

# Calculate centroids (average profile for each NhCoord20_anno cluster)
centroids <- cell_counts %>%
  group_by(NhCoord20) %>%
  summarise(across(everything(), mean))

# Convert centroids to matrix and set row names
centroids_matrix <- as.matrix(centroids[,-1])
rownames(centroids_matrix) <- centroids$NhCoord20

# Calculate tissue averages
tissue_avgs <- colMeans(cell_counts_matrix)

# Calculate fold changes
calculate_fold_change <- function(row, tissue_avgs) {
  niche_clusters <- row + tissue_avgs
  niche_sum <- sum(niche_clusters)
  log2((niche_clusters / niche_sum) / tissue_avgs)
}

fc_matrix <- t(apply(centroids_matrix, 1, calculate_fold_change, tissue_avgs))

# Rescale the fold changes to be between -3 and 3
rescale_to_range <- function(x, new_min = -3, new_max = 3) {
  old_min <- min(x)
  old_max <- max(x)
  new_min + ((x - old_min) * (new_max - new_min) / (old_max - old_min))
}

fc_matrix_rescaled <- apply(fc_matrix, 2, rescale_to_range)

# Cap values at -3 and 3
fc_matrix_rescaled[fc_matrix_rescaled < -3] <- -3
fc_matrix_rescaled[fc_matrix_rescaled > 3] <- 3

# Prepare the heatmap
# Define the color mapping function
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))

fc_matrix_rescaled <- as.data.frame(fc_matrix_rescaled)

# Create the heatmap
# Set graphics device options (if plotting to a file)
options(bitmapType = "cairo")

# Create the heatmap
heatmap <- Heatmap(fc_matrix_rescaled,
                   name = "Log2 Fold Change",
                   col = col_fun,
                   cluster_rows = TRUE,
                   cluster_columns = TRUE,
                   show_row_names = TRUE,
                   show_column_names = TRUE,
                   column_names_rot = 45,
                   row_names_side = "left",
                   column_title_side = 'bottom',
                   column_title = "Cell Types",
                   row_title = "Neighborhoods",
                   rect_gp = gpar(col = NA, lwd = 0),  # Negative line width
                   border = FALSE,
                   #width = unit(10, "inches"),  # Increase overall size
                   #height = unit(8, "inches"),
                   heatmap_legend_param = list(
                     title = "Normalized cell type enrichment score",
                     title_position = "leftcenter-rot",
                     title_gp = gpar(fontsize = 10),
                     at = c(-3, 0, 3),
                     labels = c("-3", "0", "3"),
                     legend_height = unit(4, "cm"),
                     grid_width = unit(0.5, "cm")
                   ))

# Draw the heatmap
pdf('ComplexHeatmap_celltypes_20neighborhood_complexheatmap.pdf', width = 6, height = 5)
draw(heatmap)
dev.off()
```

```{r S2B--RNA neighborhood heatmap (20 clusters)}
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

CosMX_RNA_merged$annot_cluster2[grep('inflammatory', CosMX_RNA_merged$annot_cluster2)] <- 'Fibroblast_VEGFA_iCAFs'

# Create a table of cell counts
cell_counts <- CosMX_RNA_merged@meta.data %>%
  group_by(k10_NhCoord20, annot_cluster2) %>%
  summarise(count = n()) %>%
  spread(annot_cluster2, count, fill = 0)

# Convert k10_NhCoord20_anno to row names and remove it as a column
cell_counts_matrix <- as.matrix(cell_counts[,-1])
rownames(cell_counts_matrix) <- cell_counts$k10_NhCoord20

# Calculate centroids (average profile for each k10_NhCoord20_anno cluster)
centroids <- cell_counts %>%
  group_by(k10_NhCoord20) %>%
  summarise(across(everything(), mean))

# Convert centroids to matrix and set row names
centroids_matrix <- as.matrix(centroids[,-1])
rownames(centroids_matrix) <- centroids$k10_NhCoord20

# Calculate tissue averages
tissue_avgs <- colMeans(cell_counts_matrix)

# Calculate fold changes
calculate_fold_change <- function(row, tissue_avgs) {
  niche_clusters <- row + tissue_avgs
  niche_sum <- sum(niche_clusters)
  log2((niche_clusters / niche_sum) / tissue_avgs)
}

fc_matrix <- t(apply(centroids_matrix, 1, calculate_fold_change, tissue_avgs))

# Rescale the fold changes to be between -3 and 3
rescale_to_range <- function(x, new_min = -3, new_max = 3) {
  old_min <- min(x)
  old_max <- max(x)
  new_min + ((x - old_min) * (new_max - new_min) / (old_max - old_min))
}

fc_matrix_rescaled <- apply(fc_matrix, 2, rescale_to_range)

# Cap values at -3 and 3
fc_matrix_rescaled[fc_matrix_rescaled < -3] <- -3
fc_matrix_rescaled[fc_matrix_rescaled > 3] <- 3

write.csv(fc_matrix, 'RNA_fc_matrix.csv')
write.csv(fc_matrix_rescaled, 'RNA_fc_matrix_rescaled.csv')

# Prepare the heatmap
# Define the color mapping function
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))

# Create the heatmap
heatmap <- Heatmap(fc_matrix_rescaled,
                   name = "Log2 Fold Change",
                   col = col_fun,
                   cluster_rows = TRUE,
                   cluster_columns = TRUE,
                   show_row_names = TRUE,
                   show_column_names = TRUE,
                   column_names_rot = 45,
                   row_names_side = "left",
                   column_title_side = 'bottom',
                   column_title = "Cell Types",
                   row_title = "Neighborhoods",
                   heatmap_legend_param = list(
                     title = "Normalized cell type enrichment score",
                     title_position = "leftcenter-rot",
                     title_gp = gpar(fontsize = 10),
                     at = c(-3, 0, 3),
                     labels = c("-3", "0", "3"),
                     legend_height = unit(4, "cm"),
                     grid_width = unit(0.5, "cm")
                   ))

# Draw the heatmap
pdf("RNA_celltypes_per_neighborhood_complexheatmap.pdf", width = 8, height = 6)
draw(heatmap)
dev.off()

transposed_heatmap <- Heatmap(as.data.frame(t(fc_matrix_rescaled)),
                              name = "Log2 Fold Change",
                              col = col_fun,
                              cluster_rows = TRUE,
                              cluster_columns = TRUE,
                              show_row_names = TRUE,
                              show_column_names = TRUE,
                              column_names_rot = 45,
                              row_names_side = "left",
                              column_title_side = 'bottom',
                              row_title = "Cell Types",
                              column_title = "Neighborhoods",
                              show_row_dend = FALSE,  # This line removes the row dendrogram
                              show_column_dend = FALSE,  # This line removes the column dendrogram (if you want)
                              heatmap_legend_param = list(
                                title = "Normalized cell type enrichment score",
                                title_position = "leftcenter-rot",
                                title_gp = gpar(fontsize = 10),
                                at = c(-3, 0, 3),
                                labels = c("-3", "0", "3"),
                                legend_height = unit(4, "cm"),
                                grid_width = unit(0.5, "cm")
                              ))
pdf('RNA_tranposed_celltypes_per_neighborhood_complexheatmap.pdf', width = 5, height = 5)
draw(transposed_heatmap)
dev.off()
```

```{r S2C/D--RESCALED ENRICHMENT small RNA neighborhood heatmap split by response ap/iCAF mixed & myeloid/K17}
library(Seurat)
library(circlize)
library(ComplexHeatmap)

load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

CosMX_RNA_merged$annot_cluster2[grep('inflammatory', CosMX_RNA_merged$annot_cluster2)] <- 'Fibroblast_VEGFA_iCAFs'

# Calculate fold changes
calculate_fold_change <- function(row, tissue_avgs) {
  niche_clusters <- row + tissue_avgs
  niche_sum <- sum(niche_clusters)
  log2((niche_clusters / niche_sum) / tissue_avgs)
}

# Rescale the fold changes to be between -3 and 3
rescale_to_range <- function(x, new_min = -3, new_max = 3) {
  old_min <- min(x)
  old_max <- max(x)
  new_min + ((x - old_min) * (new_max - new_min) / (old_max - old_min))
}





# responder
CosMX_RNA_merged_r <- CosMX_RNA_merged[,CosMX_RNA_merged$Response == 'R']

# Create a table of cell counts
cell_counts <- CosMX_RNA_merged_r@meta.data %>%
  group_by(k10_NhCoord20_anno, annot_cluster2) %>%
  summarise(count = n()) %>%
  spread(annot_cluster2, count, fill = 0)

# Convert k10_NhCoord20_anno to row names and remove it as a column
cell_counts_matrix <- as.matrix(cell_counts[,-1])
rownames(cell_counts_matrix) <- cell_counts$k10_NhCoord20_anno

# Calculate centroids (average profile for each k10_NhCoord20_anno cluster)
centroids <- cell_counts %>%
  group_by(k10_NhCoord20_anno) %>%
  summarise(across(everything(), mean))

# Convert centroids to matrix and set row names
centroids_matrix <- as.matrix(centroids[,-1])
rownames(centroids_matrix) <- centroids$k10_NhCoord20_anno

# Calculate tissue averages
tissue_avgs <- colMeans(cell_counts_matrix)

fc_matrix_r <- t(apply(centroids_matrix, 1, calculate_fold_change, tissue_avgs))

fc_matrix_rescaled_r <- apply(fc_matrix_r, 2, rescale_to_range)

# Cap values at -3 and 3
fc_matrix_rescaled_r[fc_matrix_rescaled_r < -3] <- -3
fc_matrix_rescaled_r[fc_matrix_rescaled_r > 3] <- 3







CosMX_RNA_merged_nr <- CosMX_RNA_merged[,CosMX_RNA_merged$Response == 'NR']

# Create a table of cell counts
cell_counts <- CosMX_RNA_merged_nr@meta.data %>%
  group_by(k10_NhCoord20_anno, annot_cluster2) %>%
  summarise(count = n()) %>%
  spread(annot_cluster2, count, fill = 0)

# Convert k10_NhCoord20_anno to row names and remove it as a column
cell_counts_matrix <- as.matrix(cell_counts[,-1])
rownames(cell_counts_matrix) <- cell_counts$k10_NhCoord20_anno

# Calculate centroids (average profile for each k10_NhCoord20_anno cluster)
centroids <- cell_counts %>%
  group_by(k10_NhCoord20_anno) %>%
  summarise(across(everything(), mean))

# Convert centroids to matrix and set row names
centroids_matrix <- as.matrix(centroids[,-1])
rownames(centroids_matrix) <- centroids$k10_NhCoord20_anno

# Calculate tissue averages
tissue_avgs <- colMeans(cell_counts_matrix)

fc_matrix_nr <- t(apply(centroids_matrix, 1, calculate_fold_change, tissue_avgs))

fc_matrix_rescaled_nr <- apply(fc_matrix_nr, 2, rescale_to_range)

# Cap values at -3 and 3
fc_matrix_rescaled_nr[fc_matrix_rescaled_nr < -3] <- -3
fc_matrix_rescaled_nr[fc_matrix_rescaled_nr > 3] <- 3


fc_matrix_rescaled_1 <- rbind(fc_matrix_rescaled_r[rownames(fc_matrix_rescaled_r) == 'DC_T_iCAF_Tumor_Mixed',],
                            fc_matrix_rescaled_nr[rownames(fc_matrix_rescaled_nr) == 'DC_T_iCAF_Tumor_Mixed',])

rownames(fc_matrix_rescaled_1) <- c('ap_iCAF_Immune_Mixed_R', 'ap_iCAF_Immune_Mixed_NR')


write.csv(fc_matrix_r, file = 'fc_matrix_r.csv')
write.csv(fc_matrix_nr, file = 'fc_matrix_nr.csv')
write.csv(fc_matrix_rescaled_r, file = 'fc_matrix_rescaled_r.csv')
write.csv(fc_matrix_rescaled_nr, file = 'fc_matrix_rescaled_nr.csv')

# Prepare the heatmap
# Define the color mapping function
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))

# Create the heatmap
heatmap1 <- Heatmap(fc_matrix_rescaled_1,
                   name = "Log2 Fold Change",
                   col = col_fun,
                   cluster_rows = F,
                   cluster_columns = F,
                   show_row_names = TRUE,
                   show_column_names = TRUE,
                   column_names_rot = 45,
                   row_names_side = "left",
                   column_title_side = 'bottom',
                   column_title = "Cell Types",
                   row_title = "Neighborhoods",
                   heatmap_legend_param = list(
                     title = "Normalized cell type enrichment score",
                     title_position = "leftcenter-rot",
                     title_gp = gpar(fontsize = 10),
                     at = c(-3, 0, 3),
                     labels = c("-3", "0", "3"),
                     legend_height = unit(4, "cm"),
                     grid_width = unit(0.5, "cm")
                   ))

# Draw the heatmap
pdf("ap_iCAF_immune_mixed_by_response_celltypes_per_neighborhood_complexheatmap.pdf", width = 7, height = 5)
draw(heatmap1)
dev.off()










# different neighborhood
fc_matrix_rescaled_2 <- rbind(fc_matrix_rescaled_r[rownames(fc_matrix_rescaled_r) == 'Myeloid_K17+_Tumor_Mixed',],
                            fc_matrix_rescaled_nr[rownames(fc_matrix_rescaled_nr) == 'Myeloid_K17+_Tumor_Mixed',])

rownames(fc_matrix_rescaled_2) <- c('Myeloid_K17+_Tumor_Mixed_R', 'Myeloid_K17+_Tumor_Mixed_NR')

# Prepare the heatmap
# Define the color mapping function
col_fun = colorRamp2(c(-3, 0, 3), c("blue", "white", "red"))

# Create the heatmap
heatmap2 <- Heatmap(fc_matrix_rescaled_2,
                   name = "Log2 Fold Change",
                   col = col_fun,
                   cluster_rows = F,
                   cluster_columns = F,
                   show_row_names = TRUE,
                   show_column_names = TRUE,
                   column_names_rot = 45,
                   row_names_side = "left",
                   column_title_side = 'bottom',
                   column_title = "Cell Types",
                   row_title = "Neighborhoods",
                   heatmap_legend_param = list(
                     title = "Normalized cell type enrichment score",
                     title_position = "leftcenter-rot",
                     title_gp = gpar(fontsize = 10),
                     at = c(-3, 0, 3),
                     labels = c("-3", "0", "3"),
                     legend_height = unit(4, "cm"),
                     grid_width = unit(0.5, "cm")
                   ))

# Draw the heatmap
pdf("Myeloid_K17+_Tumor_Mixed_by_response_celltypes_per_neighborhood_complexheatmap.pdf", width = 7, height = 5)
draw(heatmap2)
dev.off()
```

```{r S2C--apCAF/iCAF NH frequency boxplot of cell types}
# Load data
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

# Update metadata
CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20_anno == "Tumor_Immune_Mixed" ~ 'Tumor_Immune_Tcell_High',
      CosMX_RNA_merged$k10_NhCoord20_anno == "Macrophage_High" ~ "Immune_Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20_anno == "DC_T_iCAF_Tumor_Mixed" ~ "ap_iCAF_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20_anno == "CAF_Immune_Mixed" ~ "myCAF_Immune_Mixed",
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20_anno)
    ),
    col.name = "k10_NhCoord20_anno_new"
  )

# Subset data for a specific neighborhood
CosMX_nh <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new == 'ap_iCAF_Immune_Mixed']

# Frequency plot function
freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], 
                        colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs), ]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
    ggplot(df) + 
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), position = position_dodge(), 
                   alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 3) + 
      theme_bw() + 
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), 
            strip.text = element_text(size = 12), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
      scale_shape_manual(values = 1:5) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) +
      theme(legend.key.size = unit(1, 'cm'), legend.title = element_text(size=30), 
            legend.text = element_text(size=20), axis.text=element_text(size=16),axis.title=element_text(size=30), 
            legend.position = 'none') + 
      labs(y= "Neighborhood Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

# Run the function with your data and parameters
fp <- freq_plot(SEU = CosMX_nh,
                metadata='annot_cluster2',
                split.meta='Response',
                graph_type='freq_boxplot',
                out='cd4_pct_k10_RNA_', 
                out_width=11,
                out_height=7)


```

```{r S2D--Myeloid/K17+ Tumor NH frequency boxplot of cell types}
# Load data
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

# Update metadata
CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20_anno == "Tumor_Immune_Mixed" ~ 'Tumor_Immune_Tcell_High',
      CosMX_RNA_merged$k10_NhCoord20_anno == "Macrophage_High" ~ "Immune_Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20_anno == "DC_T_iCAF_Tumor_Mixed" ~ "ap_iCAF_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20_anno == "CAF_Immune_Mixed" ~ "myCAF_Immune_Mixed",
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20_anno)
    ),
    col.name = "k10_NhCoord20_anno_new"
  )

# Subset data for a specific neighborhood
CosMX_nh <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new == "Myeloid_K17+_Tumor_Mixed"]

# Frequency plot function
freq_plot <- function(SEU, metadata, split.meta = 'tissue_hpv', graph_type = c('stacked_barplot', 'freq_boxplot'), 
                      out, out_width = 12, out_height = 8, out_units = 'in', out_res = 300, test_by_group = TRUE){
  
  set.seed(329)
  
  require(ggplot2)
  require(DescTools)
  require(Seurat)
  
  
  Idents(SEU) <- metadata
  new.ident <- sort(unique(Idents(SEU)))
  samples <- unique(SEU@meta.data$orig.ident)
  tmp <- match(SEU$orig.ident, samples)
  sample_ind <- unique(tmp)
  ids <- Idents(SEU)
  tmp_v <- matrix(0, nrow = length(samples), ncol = length(new.ident))
  rownames(tmp_v) <- samples
  total_in_sample <- rep(0, length(samples))
  tmp <- SEU$orig.ident
  tmp <- plyr::count(tmp)
  total_in_sample = tmp$freq
  names(total_in_sample) <- tmp$x
  total_in_sample <- total_in_sample[match(samples, names(total_in_sample))]
  for (i in 1:length(new.ident)) {
    tmp <- ids[which(ids == new.ident[i])]
    tmp <- SEU$orig.ident[match(names(tmp), rownames(SEU@meta.data))]
    tmp <- plyr::count(tmp)
    for (j in 1:nrow(tmp)) {
      ind <- which(rownames(tmp_v) == tmp$x[j])
      tmp_v[ind,i] <- tmp$freq[j]
    }
  }
  colnames(tmp_v) <- new.ident
  ind <- order(colnames(tmp_v))
  t2 <- tmp_v
  for (i in 1:nrow(t2)) {
    t2[i,] = t2[i,]/sum(t2[i,])
  }
  t2 <- as.data.frame(t2)
  t2 <- as.matrix(t2)
  
  meta <- SEU@meta.data[,c('orig.ident', split.meta)]
  rownames(meta) <- NULL
  meta <- unique(meta)
  df <- NULL
  for (i in 1:nrow(t2)) {
    for (j in 1:ncol(t2)) {
      df <- rbind(df, c(rownames(t2)[i], meta[[split.meta]][which(meta$orig.ident == rownames(t2)[i])], 
                        colnames(t2)[j], as.numeric(t2[i,j])))
    }
  }
  colnames(df) <- c('Sample', 'Group', 'Cluster', 'Freqs')
  df <- as.data.frame(df)
  df$Group <- as.character(df$Group)
  df$Freqs <- as.numeric(as.character(df$Freqs))
  
  df <- df[!is.na(df$Freqs), ]
  
  if(isTRUE(test_by_group)){
    all_p <- data.frame(subset = character(), p = numeric())
    
    for (x in unique(df$Cluster)) {
      f <- df[df$Cluster == x,]
      groups <- unique(df$Group)
      f1 <- f[f$Group == groups[1],]$Freqs
      f2 <- f[f$Group == groups[2],]$Freqs
      wcx <- wilcox.test(f1, f2, paired = FALSE)
      row <- c(x, wcx$p.value)
      all_p <- rbind(all_p, row)
      all_p[,2] <- format(round(as.numeric(all_p[,2]), 2), nsmall = 2)
    }
    
    p_filtered <- all_p
    
    sub_title <- paste(p_filtered[,1], p_filtered[,2], sep = '=')
  }
  
  write.csv(all_p, paste(out, 'freq_boxplot_wilcox.csv', sep = ''))
  
  df$Freqs <- df$Freqs * 100
  
  if (graph_type == 'freq_boxplot'){
    ggplot(df) + 
      geom_boxplot(aes(x = Group, y = Freqs, color = Group, fill = Group), position = position_dodge(), 
                   alpha = 0.5, outlier.color = NA) + 
      geom_point(aes(x = Group, y = Freqs, color = Group), alpha = 0.8, position = position_jitterdodge()) + 
      facet_wrap(~ Cluster, scales = 'free', nrow = 3) + 
      theme_bw() + 
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank(), 
            strip.text = element_text(size = 12), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
      scale_shape_manual(values = 1:5) + 
      scale_color_manual(values = c('#2196F3', '#FF8A80')) +
      scale_fill_manual(values = c('#2196F3', '#FF8A80')) +
      theme(legend.key.size = unit(1, 'cm'), legend.title = element_text(size=30), 
            legend.text = element_text(size=20), axis.text=element_text(size=16),axis.title=element_text(size=30), 
            legend.position = 'none') + 
      labs(y= "Neighborhood Frequency")
    
    ggsave(paste(out, 'freq_boxplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    write.csv(df, file = paste(out, 'freq_boxplot_data.csv', sep = ''))
    return(df)
  }
  if (graph_type == 'stacked_barplot'){
    pdf(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, res = out_res)
    ggplot(df) +geom_bar(aes(x = Group, y = Freqs, fill = Cluster), position = 'stack', stat = 'identity') + scale_fill_manual(values=color_clusters[1:as.numeric(length(unique(df$Cluster)))]) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
    
    ggsave(paste(out, 'stacked_barplot.pdf', sep = ''), width = out_width, height = out_height, units = out_units, dpi = out_res)
    dev.off()
    write.csv(df, file = paste(out, 'stacked_barplot_data.csv', sep = ''))
    return(df)
  }
}

# Run the function with your data and parameters
fp <- freq_plot(SEU = CosMX_nh,
                metadata='annot_cluster2',
                split.meta='Response',
                graph_type='freq_boxplot',
                out='myeloid_K17_tumor_NH_pct_k10_RNA_', 
                out_width=12,
                out_height=7)
```

```{r S2E--CXCL10/CXCR3 3 way average distance plot}
library(dplyr)
library(Seurat)
library(ggplot2)
library(ggpubr)

# Load data
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

# Preprocessing
CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20_anno == "Tumor_Immune_Mixed" ~ 'Tumor_Immune_Tcell_High',
      CosMX_RNA_merged$k10_NhCoord20_anno == "Macrophage_High" ~ "Immune_Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20_anno == "DC_T_iCAF_Tumor_Mixed" ~ "ap_iCAF_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20_anno == "CAF_Immune_Mixed" ~ "myCAF_Immune_Mixed",
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20_anno)
    ),
    col.name = "k10_NhCoord20_anno_new"
  )


# Modified Euclidean distance function for three cell types using average locations
euclidean_distance_3d_avg <- function(df1, df2, df3) {
  if (nrow(df1) == 0 || nrow(df2) == 0 || nrow(df3) == 0) {
    return(data.frame())
  }
  
  # Calculate average x and y coordinates for each cell type
  avg_df1 <- colMeans(df1[, c("x_pixel", "y_pixel")])
  avg_df2 <- colMeans(df2[, c("x_pixel", "y_pixel")])
  avg_df3 <- colMeans(df3[, c("x_pixel", "y_pixel")])
  
  # Combine average coordinates
  avg_coords <- rbind(avg_df1, avg_df2, avg_df3)
  
  # Calculate distances between average points
  distances <- as.matrix(dist(avg_coords))
  
  # Calculate average distance
  avg_distance <- mean(distances[upper.tri(distances)])
  
  return(data.frame(avg_distance = avg_distance))
}

analyze_distances <- function(data, senders, receivers, tumors, CosMx_RNA_ligand, CosMx_RNA_receptor) {
  nhs <- unique(data$k10_NhCoord20_anno_new)
  fovs <- unique(data$tma_fov_id)
  
  distances <- data.frame(
    Neighborhood = character(),
    Response = character(),
    sender = character(),
    receiver = character(),
    tumor = character(),
    fov = character(),
    average_distance = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (nh in nhs) {
    for (fov in fovs) {
      tryCatch({
        pixel_locs1 <- CosMx_RNA_ligand[,CosMx_RNA_ligand$k10_NhCoord20_anno_new == nh & CosMx_RNA_ligand$annot_cluster2 %in% senders & CosMx_RNA_ligand$tma_fov_id == fov][[c('x_pixel', 'y_pixel', 'annot_cluster2', 'Response', 'tma_fov_id')]]
        pixel_locs2 <- CosMx_RNA_receptor[,CosMx_RNA_receptor$k10_NhCoord20_anno_new == nh & CosMx_RNA_receptor$annot_cluster2 %in% receivers & CosMx_RNA_receptor$tma_fov_id == fov][[c('x_pixel', 'y_pixel', 'annot_cluster2', 'Response', 'tma_fov_id')]]
        
        # Adjust tumor cell selection based on neighborhood
        if (nh == "Myeloid_K17+_Tumor_Mixed") {
          pixel_locs3_krt17 <- CosMX_RNA_merged_immuneNHs[,CosMX_RNA_merged_immuneNHs$k10_NhCoord20_anno_new == nh & CosMX_RNA_merged_immuneNHs$annot_cluster2 == "Tumors_KRT17+" & CosMX_RNA_merged_immuneNHs$tma_fov_id == fov][[c('x_pixel', 'y_pixel', 'annot_cluster2', 'Response', 'tma_fov_id')]]
          pixel_locs3_others <- CosMX_RNA_merged_immuneNHs[,CosMX_RNA_merged_immuneNHs$k10_NhCoord20_anno_new == nh & CosMX_RNA_merged_immuneNHs$annot_cluster2 %in% c("Tumors_HIF1A+", "Tumors_KRT19+", "Tumors_Others") & CosMX_RNA_merged_immuneNHs$tma_fov_id == fov][[c('x_pixel', 'y_pixel', 'annot_cluster2', 'Response', 'tma_fov_id')]]
          tumor_subsets <- list("Tumors_KRT17+" = pixel_locs3_krt17, "Tumors_Others" = pixel_locs3_others)
        } else {
          pixel_locs3 <- CosMX_RNA_merged_immuneNHs[,CosMX_RNA_merged_immuneNHs$k10_NhCoord20_anno_new == nh & CosMX_RNA_merged_immuneNHs$annot_cluster2 %in% tumors & CosMX_RNA_merged_immuneNHs$tma_fov_id == fov][[c('x_pixel', 'y_pixel', 'annot_cluster2', 'Response', 'tma_fov_id')]]
          tumor_subsets <- list("All_Tumors" = pixel_locs3)
        }
        
        if (nrow(pixel_locs1) == 0 || nrow(pixel_locs2) == 0 || all(sapply(tumor_subsets, nrow) == 0)) {
          next
        }
        
        response <- unique(pixel_locs1$Response)
        
        for (s in senders) {
          for (r in receivers) {
            for (t in names(tumor_subsets)) {
              pixel_locs1_s <- pixel_locs1[pixel_locs1$annot_cluster2 == s, ]
              pixel_locs2_r <- pixel_locs2[pixel_locs2$annot_cluster2 == r, ]
              pixel_locs3_t <- tumor_subsets[[t]]
              
              if (nrow(pixel_locs1_s) == 0 || nrow(pixel_locs2_r) == 0 || nrow(pixel_locs3_t) == 0) {
                next
              }
              
              result <- euclidean_distance_3d_avg(pixel_locs1_s, pixel_locs2_r, pixel_locs3_t)
              
              if (nrow(result) > 0) {
                new_row <- data.frame(
                  Neighborhood = nh,
                  Response = response,
                  sender = s,
                  receiver = r,
                  tumor = t,
                  fov = fov,
                  average_distance = result$avg_distance,
                  stringsAsFactors = FALSE
                )
                distances <- rbind(distances, new_row)
              }
            }
          }
        }
      }, error = function(e) {
        cat("Error encountered for FOV:", fov, "\n")
        cat("Error message:", e$message, "\n")
      })
    }
  }
  
  return(distances)
}


DefaultAssay(CosMX_RNA_merged) <- 'RNA'
senders <- c('DCs', 'Monocytes', 'Macrophages')
receivers <- c('Tcells_CD4+', 'TcellsCD8+', 'Tregs')
CosMX_RNA_merged_immuneNHs <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new != c("Tumor_High", "CAFs", "Bcell_Plasma", "Endothelial")]
tumors <- c("Tumors_KRT17+", "Tumors_HIF1A+", "Tumors_KRT19+", "Tumors_Others")

CosMx_RNA_ligand = subset(x = CosMX_RNA_merged_immuneNHs, subset = CXCL10 > 0)
CosMx_RNA_receptor = subset(x = CosMX_RNA_merged_immuneNHs, subset = CXCR3 > 0)
CosMX_RNA_merged <- NULL

distances <- analyze_distances(data = CosMX_RNA_merged_immuneNHs, 
                               senders = senders, 
                               receivers = receivers, 
                               tumors = tumors, 
                               CosMx_RNA_ligand = CosMx_RNA_ligand,
                               CosMx_RNA_receptor = CosMx_RNA_receptor)



# Save results
write.csv(distances, 'cxcl10_cxcr3_lr_filtered_myeloid_to_tcell_tumor_distance_by_nh_by_response.csv')

# Overall plot
ggplot(distances) + 
  geom_boxplot(aes(x = paste(sender, receiver, tumor, Response), y = average_distance, color = Response, fill = Response), 
               position = position_dodge(), alpha = 0.5, outlier.color = NA) + 
  geom_point(aes(x = paste(sender, receiver, tumor, Response), y = average_distance, color = Response), 
             alpha = 0.8, position = position_jitterdodge()) + 
  facet_wrap(~ Neighborhood, scales = 'free', nrow = 2) + 
  theme_bw() + 
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
    axis.ticks.x = element_blank(), axis.title.x = element_blank(), 
    strip.text = element_text(size = 12), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  scale_shape_manual(values = 1:5) + 
  scale_color_manual(values = c('#2196F3', '#FF8A80')) +
  scale_fill_manual(values = c('#2196F3', '#FF8A80')) +
  theme(legend.key.size = unit(1, 'cm'), legend.title = element_text(size=30), 
        legend.text = element_text(size=20), axis.text=element_text(size=16),axis.title=element_text(size=30), 
        legend.position = 'none') + 
  labs(y= "Average Distance b/t Sender, Receiver, and Tumor Cell Types")

ggsave("overall_cxcl10_cxcr3_lr_filtered_distance_boxplot_with_tumor.pdf", width = 30, height = 20, units = "in")

# Individual plots for each neighborhood
for (nh in unique(distances$Neighborhood)) {
  distances_subset <- distances[distances$Neighborhood == nh, ]
  
  p <- ggplot(distances_subset) +
    geom_boxplot(aes(x = Response, y = average_distance, fill = Response, color = Response), alpha = 0.5, outlier.color = NA) +
    geom_point(aes(x = Response, y = average_distance, fill = Response, color = Response), alpha = 0.8, position = position_jitterdodge()) +
    facet_grid(sender + receiver ~ tumor) +
    stat_compare_means(aes(x = Response, y = average_distance, fill = Response), label = "p.format") +
    theme_bw() +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
      strip.text = element_text(size = 12),
      panel.grid.major = element_blank(), 
      panel.grid.minor = element_blank(),
      legend.position = "none"
    ) +
    scale_fill_manual(values = c('#2196F3', '#FF8A80')) +
    scale_color_manual(values = c('#2196F3', '#FF8A80')) +
    labs(title = paste("Average Distance in", nh), y = "Average Distance")
  
  ggsave(paste0("cxcl10_cxcr3_lr_filtered_distance_boxplot_with_tumor_", nh, ".png"), p, width = 12, height = 25, units = "in")
}


```

```{r S3A--Chemokine pathway rank plot (sender receiver only) with jitter}
load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_cytokine/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# non-responder pre-treatment
nr_pre <- as.data.frame(nr_pre_cellchat@net$count) %>%
  rownames_to_column()
nr_pre <- nr_pre[grep('Mac|Mon|DC', nr_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_pre))]
nr_pre <- nr_pre %>%
  pivot_longer(cols = 2:ncol(nr_pre), names_to = 'receiver', values_to = 'NR_pre_prob') #%>%
#rename(sender = rowname)
nr_pre$SR <- paste(nr_pre$rowname, nr_pre$receiver, sep = '_')

# non-responder post-treatment
nr_post <- as.data.frame(nr_post_cellchat@net$count) %>%
  rownames_to_column()
nr_post <- nr_post[grep('Mac|Mon|DC', nr_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_post))]
nr_post <- nr_post %>%
  pivot_longer(cols = 2:ncol(nr_post), names_to = 'receiver', values_to = 'NR_post_prob') #%>%
#rename(sender = rowname)
nr_post$SR <- paste(nr_post$rowname, nr_post$receiver, sep = '_')

# Responder pre-treatment
r_pre <- as.data.frame(r_pre_cellchat@net$count) %>%
  rownames_to_column()
r_pre <- r_pre[grep('Mac|Mon|DC', r_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_pre))]
r_pre <- r_pre %>%
  pivot_longer(cols = 2:ncol(r_pre), names_to = 'receiver', values_to = 'R_pre_prob') #%>%
#rename(sender = rowname)
r_pre$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# Responder post-treatment
r_post <- as.data.frame(r_post_cellchat@net$count) %>%
  rownames_to_column()
r_post <- r_post[grep('Mac|Mon|DC', r_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_post))]
r_post <- r_post %>%
  pivot_longer(cols = 2:ncol(r_post), names_to = 'receiver', values_to = 'R_post_prob') #%>%
#rename(sender = rowname)
r_post$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC))

post <- merge(r_post, nr_post, by = 'SR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC))

post <- post[!post$rowname.x == 'Mac_SPP1',]

# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 0.2 ~ "R_enriched",
  pre$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 0.2 ~ "R_enriched",
  post$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

pre <- pre[pre$log2FC != Inf,]
post <- post[post$log2FC != Inf,]

pre <- pre %>%
  mutate(rank = row_number())

post <- post %>%
  mutate(rank = row_number())

# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00",
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7",
                      'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Function to create the label grob
create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}

# Jitter strength (adjust this value)
jitter_strength <- 0.05

# Function to create the rank plot with grob jitter
create_rank_plot <- function(data, title) {
  p <- ggplot(data, aes(x = rank, y = log2FC)) +
    # Add white dots for points outside -0.2 and 0.2
    geom_point(data = subset(data, log2FC < -0.2 | log2FC > 0.2),
               color = "white", size = 2) +
    # Add black dots for points between -0.2 and 0.2
    geom_point(data = subset(data, log2FC >= -0.2 & log2FC <= 0.2),
               color = "black", size = 1) +
    theme_classic() +
    labs(title = title,
         x = "CCI rank", y = "log2FC(R/NR count)") +
    theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
          legend.position = "none", axis.text = element_text(size = 12),
          axis.title = element_text(size = 18, face = "bold"))

  # Add custom annotations with jitter
  significant_points <- subset(data, log2FC > 0.2 | log2FC < -0.2)
  for (i in 1:nrow(significant_points)) {
    label_grob <- create_label_grob(
      significant_points$rowname.x[i],
      significant_points$receiver.x[i],
      sender_colors[significant_points$rowname.x[i]],
      receiver_colors[significant_points$receiver.x[i]]
    )

    # Apply jitter to ymin and ymax
    jitter_value <- runif(1, -jitter_strength, jitter_strength)

    p <- p + annotation_custom(
      grob = label_grob,
      xmin = significant_points$rank[i] - 0.75,
      xmax = significant_points$rank[i] + 0.75,
      ymin = significant_points$log2FC[i] - 0.2 + jitter_value,  # Jittered ymin
      ymax = significant_points$log2FC[i] + 0.2 + jitter_value   # Jittered ymax
    )
  }

  # Add horizontal lines at y = 0.2 and y = -0.2
  p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

  # Add legends for sender and receiver colors with correct order and appearance
  p <- p + scale_color_manual(name = "Sender",
                               values = sender_colors,
                               breaks = names(sender_colors),
                               guide = guide_legend(order = 1,
                                                    override.aes = list(shape = 21,
                                                                        size = 5,
                                                                        fill = NA))) +
    scale_fill_manual(name = "Receiver",
                      values = receiver_colors,
                      breaks = names(receiver_colors),
                      guide = guide_legend(order = 2,
                                           override.aes = list(shape = 21,
                                                               size = 5,
                                                               color = NA)))

  # Adjust legend appearance and layout
  p <- p + theme(
    legend.key = element_rect(colour = NA),
    legend.key.size = unit(1.2, "cm"),
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 16, face = "bold"),
    legend.position = "none",
    legend.box = "vertical",
    legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
    legend.box.margin = margin(0, 0, 0, 0),
    legend.spacing.x = unit(0, 'cm'),
    legend.spacing.y = unit(0, 'cm'),
    plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
  )

  # Adjust the guide for sender legend to use two rows, keep receiver legend as one row
  p <- p + guides(
    color = guide_legend(nrow = 2, byrow = TRUE, order = 1,
                         override.aes = list(shape = 21,
                                             size = 6,
                                             fill = NA)),
    fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                        override.aes = list(shape = 21,
                                            size = 6,
                                            color = NA))
  )

  return(p)
}

# Create pre-treatment plot
pre_plot <- create_rank_plot(pre, "Chemokine Pre-ICB")
# Save the plot
pdf('ChemokinePathway_PreTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(pre_plot)
dev.off()

# Create post-treatment plot
post_plot <- create_rank_plot(post, "Chemokine Post-ICB")

# Save the plot
pdf('ChemokinePathway_PostTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(post_plot)
dev.off()

```

```{r S3A--UpSet plot mregDC sender}
load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma/all_cellchat_objs.rda')

#combined upset plots
create_combined_upset_plot <- function(cellchat, sender, target, group1, group2, desired_order, output_file) {
  library(dplyr)
  library(ComplexHeatmap)
  library(UpSetR)
  
  # Extract and prepare the interaction data for each group
  cellchat_count_group1 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group1]] %>% 
    select(c('target', 'ligand', 'receptor'))
  cellchat_count_group2 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group2]] %>% 
    select(c('target', 'ligand', 'receptor'))
  
  # Create interaction string without the target/receiver
  cellchat_count_group1$interaction <- paste(cellchat_count_group1$ligand, cellchat_count_group1$receptor, sep = '->')
  cellchat_count_group2$interaction <- paste(cellchat_count_group2$ligand, cellchat_count_group2$receptor, sep = '->')
  
  # Create a list of interactions for each receiver
  interaction_list1 <- split(cellchat_count_group1$interaction, cellchat_count_group1$target)
  interaction_list2 <- split(cellchat_count_group2$interaction, cellchat_count_group2$target)
  
  # Filter out sets with a list length of zero
  interaction_list1 <- interaction_list1[sapply(interaction_list1, length) > 0]
  interaction_list2 <- interaction_list2[sapply(interaction_list2, length) > 0]
  
  # Append group IDs to the set names
  names(interaction_list1) <- paste(names(interaction_list1), group1, sep = "_")
  names(interaction_list2) <- paste(names(interaction_list2), group2, sep = "_")
  
  # Combine the interaction lists
  combined_interaction_list <- c(interaction_list1, interaction_list2)
  
  # Create a combination matrix
  comb_mat_combined <- make_comb_mat(combined_interaction_list)
  
  # Filter out empty columns (those with no intersection size)
  non_empty_columns <- comb_degree(comb_mat_combined) > 0
  comb_mat_combined_filtered <- comb_mat_combined[, non_empty_columns]
  
  # Create a custom color vector based on the set combinations
  intersection_colors <- sapply(seq_len(ncol(comb_mat_combined_filtered)), function(i) {
    sets_in_comb <- rownames(comb_mat_combined_filtered)[comb_mat_combined_filtered[,i] == 1]
    r_sets <- sum(grepl("_R$", sets_in_comb))
    nr_sets <- sum(grepl("_NR$", sets_in_comb))
    
    if (r_sets > 0 && nr_sets == 0) {
      return("#B71C1C")  # Color for "_R" only
    } else if (nr_sets > 0 && r_sets == 0) {
      return('#2196F3')  # Color for "_NR" only
    } else if (r_sets > 0 && nr_sets > 0) {
      return("grey20")  # Color for both
    } else {
      return("grey50")  # Default color
    }
  })
  
  # Generate the UpSet plot
  tryCatch({
    grDevices::pdf(output_file, width = 6, height = 4)
    print(UpSet(comb_mat_combined_filtered, 
                pt_size = unit(5, "mm"), 
                lwd = 3, 
                comb_col = intersection_colors, 
                bg_col = c("grey90", "grey100"), 
                bg_pt_col = "grey70",
                set_order = desired_order))
  }, finally = {
    grDevices::dev.off()
  })
  
  # Check if the file was created successfully
  if (file.exists(output_file) && file.size(output_file) > 4096) {
    message("PDF file created successfully: ", output_file)
  } else {
    warning("PDF file creation may have failed or file is too small: ", output_file)
  }
  
  # Sanity check: Create a table of the number of interactions per set
  interactions_per_set <- sapply(combined_interaction_list, length)
  interactions_table <- data.frame(
    Set = names(interactions_per_set),
    Number_of_Interactions = interactions_per_set
  )
  
  # Sanity check: Get contributing interactions for each set
  contributing_interactions <- lapply(names(combined_interaction_list), function(set_name) {
    data.frame(
      Set = set_name,
      Interaction = combined_interaction_list[[set_name]]
    )
  })
  contributing_interactions <- do.call(rbind, contributing_interactions)
  
  # Sanity check: Get intersections and their sizes
  intersections <- comb_size(comb_mat_combined_filtered)
  intersection_sizes <- data.frame(
    Intersection = names(intersections),
    Size = intersections
  )
  
  # Create a list of returned objects
  returned_objects <- list(
    interactions_table = interactions_table,
    contributing_interactions = contributing_interactions,
    intersection_sizes = intersection_sizes,
    comb_mat = comb_mat_combined_filtered, 
    combined_interaction_list = combined_interaction_list
  )
  
  # Return the list of objects
  return(returned_objects)
}


# Example usage
original_receivers = c('IL7R_CD4', 'ITGAE_CD8', 'GZMK_CD8', 'NR4A2_CD8', 'CXCL13_Tcells', 'Tregs')

# Duplicate the vector and append "_R" and "_NR"
receivers_R <- paste(original_receivers, "_R", sep = "")
receivers_NR <- paste(original_receivers, "_NR", sep = "")

# Combine and rearrange the order
combined_receivers <- c(receivers_NR, receivers_R)

mreg_post <- create_combined_upset_plot(cellchat = post.cellchat, 
                           sender = 'mregDC_LAMP3',
                           target = unique(grep('CD4|CD8|Tcells|Tregs', post.cellchat@meta$consensus_clusters, value = T)), 
                           group1 = "NR", 
                           group2 = "R", 
                           desired_order = combined_receivers, 
                           output_file = "post_tx_mregDC_combined_UpsetPlot.pdf")
mreg_pre <- create_combined_upset_plot(cellchat = pre.cellchat, 
                                        sender = 'mregDC_LAMP3',
                                        target = unique(grep('CD4|CD8|Tcells|Tregs', pre.cellchat@meta$consensus_clusters, value = T)), 
                                        group1 = "NR", 
                                        group2 = "R", 
                                        desired_order = combined_receivers, 
                                        output_file = "pre_tx_mregDC_combined_UpsetPlot.pdf")
```

```{r S3B--Complement pathway rank plot (sender receiver only)}
library(ggplot2)
library(grid)
library(dplyr)
library(tidyr)

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_complement/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# non-responder pre-treatment
nr_pre <- as.data.frame(nr_pre_cellchat@net$count) %>%
  rownames_to_column()
nr_pre <- nr_pre[grep('Mac|Mon|DC', nr_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_pre))]
nr_pre <- nr_pre %>%
  pivot_longer(cols = 2:ncol(nr_pre), names_to = 'receiver', values_to = 'NR_pre_prob') #%>%
#rename(sender = rowname)
nr_pre$SR <- paste(nr_pre$rowname, nr_pre$receiver, sep = '_')

# non-responder post-treatment
nr_post <- as.data.frame(nr_post_cellchat@net$count) %>%
  rownames_to_column()
nr_post <- nr_post[grep('Mac|Mon|DC', nr_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_post))]
nr_post <- nr_post %>%
  pivot_longer(cols = 2:ncol(nr_post), names_to = 'receiver', values_to = 'NR_post_prob') #%>%
#rename(sender = rowname)
nr_post$SR <- paste(nr_post$rowname, nr_post$receiver, sep = '_')

# Responder pre-treatment
r_pre <- as.data.frame(r_pre_cellchat@net$count) %>%
  rownames_to_column()
r_pre <- r_pre[grep('Mac|Mon|DC', r_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_pre))]
r_pre <- r_pre %>%
  pivot_longer(cols = 2:ncol(r_pre), names_to = 'receiver', values_to = 'R_pre_prob') #%>%
#rename(sender = rowname)
r_pre$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# Responder post-treatment
r_post <- as.data.frame(r_post_cellchat@net$count) %>%
  rownames_to_column()
r_post <- r_post[grep('Mac|Mon|DC', r_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_post))]
r_post <- r_post %>%
  pivot_longer(cols = 2:ncol(r_post), names_to = 'receiver', values_to = 'R_post_prob') #%>%
#rename(sender = rowname)
r_post$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC))

post <- merge(r_post, nr_post, by = 'SR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC))

post <- post[!post$rowname.x == 'Mac_SPP1',]

# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 0.2 ~ "R_enriched",
  pre$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 0.2 ~ "R_enriched",
  post$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

pre <- pre[pre$log2FC != Inf,]
post <- post[post$log2FC != Inf,]

pre <- pre %>%
  mutate(rank = row_number())

post <- post %>%
  mutate(rank = row_number())

# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00",
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7",
                      'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Function to create the label grob
create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}

# Jitter strength (adjust this value)
jitter_strength <- 0.05

# Create the base plot with all points--post-treatment
# Pre-treatment plot
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(pre, log2FC < -0.2 | log2FC > 0.2),
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(pre, log2FC >= -0.2 & log2FC <= 0.2),
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Complement Pre-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(pre, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )

  # Apply jitter to ymin and ymax
  jitter_value <- runif(1, -jitter_strength, jitter_strength)  # Random jitter

  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2 + jitter_value,
    ymax = significant_points$log2FC[i] + 0.2 + jitter_value
  )
}

# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender",
                             values = sender_colors,
                             breaks = names(sender_colors),
                             guide = guide_legend(order = 1,
                                                  override.aes = list(shape = 21,
                                                                      size = 5,
                                                                      fill = NA))) +
  scale_fill_manual(name = "Receiver",
                     values = receiver_colors,
                     breaks = names(receiver_colors),
                     guide = guide_legend(order = 2,
                                          override.aes = list(shape = 21,
                                                              size = 5,
                                                              color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1,
                       override.aes = list(shape = 21,
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21,
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('ComplementPathway_PreTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()


# ################################################################################
# ####### POST-TX
##################################################################################
# sender and receiver data is the same

# Create the base plot with all points--post-treatment

p <- ggplot(post, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(post, log2FC < -0.2 | log2FC > 0.2),
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(post, log2FC >= -0.2 & log2FC <= 0.2),
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Complement Post-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(post, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )

  # Apply jitter to ymin and ymax
  jitter_value <- runif(1, -jitter_strength, jitter_strength)  # Random jitter

  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2 + jitter_value,
    ymax = significant_points$log2FC[i] + 0.2 + jitter_value
  )
}


# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender",
                             values = sender_colors,
                             breaks = names(sender_colors),
                             guide = guide_legend(order = 1,
                                                  override.aes = list(shape = 21,
                                                                      size = 5,
                                                                      fill = NA))) +
  scale_fill_manual(name = "Receiver",
                     values = receiver_colors,
                     breaks = names(receiver_colors),
                     guide = guide_legend(order = 2,
                                          override.aes = list(shape = 21,
                                                              size = 5,
                                                              color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1,
                       override.aes = list(shape = 21,
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21,
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('ComplementPathway_PostTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()

```

```{r S3B--UpSet plot Mac CXCL9 sender}
load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma/all_cellchat_objs.rda')

#combined upset plots
create_combined_upset_plot <- function(cellchat, sender, target, group1, group2, desired_order, output_file) {
  library(dplyr)
  library(ComplexHeatmap)
  library(UpSetR)
  
  # Extract and prepare the interaction data for each group
  cellchat_count_group1 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group1]] %>% 
    select(c('target', 'ligand', 'receptor'))
  cellchat_count_group2 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group2]] %>% 
    select(c('target', 'ligand', 'receptor'))
  
  # Create interaction string without the target/receiver
  cellchat_count_group1$interaction <- paste(cellchat_count_group1$ligand, cellchat_count_group1$receptor, sep = '->')
  cellchat_count_group2$interaction <- paste(cellchat_count_group2$ligand, cellchat_count_group2$receptor, sep = '->')
  
  # Create a list of interactions for each receiver
  interaction_list1 <- split(cellchat_count_group1$interaction, cellchat_count_group1$target)
  interaction_list2 <- split(cellchat_count_group2$interaction, cellchat_count_group2$target)
  
  # Filter out sets with a list length of zero
  interaction_list1 <- interaction_list1[sapply(interaction_list1, length) > 0]
  interaction_list2 <- interaction_list2[sapply(interaction_list2, length) > 0]
  
  # Append group IDs to the set names
  names(interaction_list1) <- paste(names(interaction_list1), group1, sep = "_")
  names(interaction_list2) <- paste(names(interaction_list2), group2, sep = "_")
  
  # Combine the interaction lists
  combined_interaction_list <- c(interaction_list1, interaction_list2)
  
  # Create a combination matrix
  comb_mat_combined <- make_comb_mat(combined_interaction_list)
  
  # Filter out empty columns (those with no intersection size)
  non_empty_columns <- comb_degree(comb_mat_combined) > 0
  comb_mat_combined_filtered <- comb_mat_combined[, non_empty_columns]
  
  # Create a custom color vector based on the set combinations
  intersection_colors <- sapply(seq_len(ncol(comb_mat_combined_filtered)), function(i) {
    sets_in_comb <- rownames(comb_mat_combined_filtered)[comb_mat_combined_filtered[,i] == 1]
    r_sets <- sum(grepl("_R$", sets_in_comb))
    nr_sets <- sum(grepl("_NR$", sets_in_comb))
    
    if (r_sets > 0 && nr_sets == 0) {
      return("#B71C1C")  # Color for "_R" only
    } else if (nr_sets > 0 && r_sets == 0) {
      return('#2196F3')  # Color for "_NR" only
    } else if (r_sets > 0 && nr_sets > 0) {
      return("grey20")  # Color for both
    } else {
      return("grey50")  # Default color
    }
  })
  
  # Generate the UpSet plot
  tryCatch({
    grDevices::pdf(output_file, width = 6, height = 4)
    print(UpSet(comb_mat_combined_filtered, 
                pt_size = unit(5, "mm"), 
                lwd = 3, 
                comb_col = intersection_colors, 
                bg_col = c("grey90", "grey100"), 
                bg_pt_col = "grey70",
                set_order = desired_order))
  }, finally = {
    grDevices::dev.off()
  })
  
  # Check if the file was created successfully
  if (file.exists(output_file) && file.size(output_file) > 4096) {
    message("PDF file created successfully: ", output_file)
  } else {
    warning("PDF file creation may have failed or file is too small: ", output_file)
  }
  
  # Sanity check: Create a table of the number of interactions per set
  interactions_per_set <- sapply(combined_interaction_list, length)
  interactions_table <- data.frame(
    Set = names(interactions_per_set),
    Number_of_Interactions = interactions_per_set
  )
  
  # Sanity check: Get contributing interactions for each set
  contributing_interactions <- lapply(names(combined_interaction_list), function(set_name) {
    data.frame(
      Set = set_name,
      Interaction = combined_interaction_list[[set_name]]
    )
  })
  contributing_interactions <- do.call(rbind, contributing_interactions)
  
  # Sanity check: Get intersections and their sizes
  intersections <- comb_size(comb_mat_combined_filtered)
  intersection_sizes <- data.frame(
    Intersection = names(intersections),
    Size = intersections
  )
  
  # Create a list of returned objects
  returned_objects <- list(
    interactions_table = interactions_table,
    contributing_interactions = contributing_interactions,
    intersection_sizes = intersection_sizes,
    comb_mat = comb_mat_combined_filtered, 
    combined_interaction_list = combined_interaction_list
  )
  
  # Return the list of objects
  return(returned_objects)
}


# Example usage
original_receivers = c('IL7R_CD4', 'ITGAE_CD8', 'GZMK_CD8', 'NR4A2_CD8', 'CXCL13_Tcells', 'Tregs')

# Duplicate the vector and append "_R" and "_NR"
receivers_R <- paste(original_receivers, "_R", sep = "")
receivers_NR <- paste(original_receivers, "_NR", sep = "")

# Combine and rearrange the order
combined_receivers <- c(receivers_NR, receivers_R)

mac_post <- create_combined_upset_plot(cellchat = post.cellchat, 
                           sender = 'Mac_CXCL9',
                           target = unique(grep('CD4|CD8|Tcells|Tregs', post.cellchat@meta$consensus_clusters, value = T)), 
                           group1 = "NR", 
                           group2 = "R", 
                           desired_order = combined_receivers, 
                           output_file = "post_tx_Mac_CXCL9_combined_UpsetPlot.pdf")
mac_pre <- create_combined_upset_plot(cellchat = pre.cellchat, 
                                        sender = 'Mac_CXCL9',
                                        target = unique(grep('CD4|CD8|Tcells|Tregs', pre.cellchat@meta$consensus_clusters, value = T)), 
                                        group1 = "NR", 
                                        group2 = "R", 
                                        desired_order = combined_receivers, 
                                        output_file = "pre_tx_Mac_CXCL9_combined_UpsetPlot.pdf")
```

```{r S3C--Costim/Coinhib pathway rank plot (sender receiver only)}
load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_costim_coinhib/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# non-responder pre-treatment
nr_pre <- as.data.frame(nr_pre_cellchat@net$count) %>% 
  rownames_to_column() 
nr_pre <- nr_pre[grep('Mac|Mon|DC', nr_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_pre))]
nr_pre <- nr_pre %>%
  pivot_longer(cols = 2:ncol(nr_pre), names_to = 'receiver', values_to = 'NR_pre_prob') #%>%
  #rename(sender = rowname)
nr_pre$SR <- paste(nr_pre$rowname, nr_pre$receiver, sep = '_')

# non-responder post-treatment
nr_post <- as.data.frame(nr_post_cellchat@net$count) %>% 
  rownames_to_column()
nr_post <- nr_post[grep('Mac|Mon|DC', nr_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(nr_post))]
nr_post <- nr_post %>%
  pivot_longer(cols = 2:ncol(nr_post), names_to = 'receiver', values_to = 'NR_post_prob') #%>%
  #rename(sender = rowname)
nr_post$SR <- paste(nr_post$rowname, nr_post$receiver, sep = '_')

# Responder pre-treatment
r_pre <- as.data.frame(r_pre_cellchat@net$count) %>% 
  rownames_to_column()
r_pre <- r_pre[grep('Mac|Mon|DC', r_pre$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_pre))]
r_pre <- r_pre %>%
  pivot_longer(cols = 2:ncol(r_pre), names_to = 'receiver', values_to = 'R_pre_prob') #%>%
  #rename(sender = rowname)
r_pre$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')

# Responder post-treatment
r_post <- as.data.frame(r_post_cellchat@net$count) %>% 
  rownames_to_column()
r_post <- r_post[grep('Mac|Mon|DC', r_post$rowname), grep('CD4|CD8|Treg|Tcells|rowname', colnames(r_post))]
r_post <- r_post %>%
  pivot_longer(cols = 2:ncol(r_post), names_to = 'receiver', values_to = 'R_post_prob') #%>%
  #rename(sender = rowname)
r_post$SR <- paste(r_pre$rowname, r_pre$receiver, sep = '_')



# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC)) 
post <- merge(r_post, nr_post, by = 'SR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) 


# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 0.2 ~ "R_enriched",
  pre$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 0.2 ~ "R_enriched",
  post$log2FC < -0.2 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

pre <- pre[pre$log2FC != Inf,]
post <- post[post$log2FC != Inf,]

pre <- pre %>%
  mutate(rank = row_number())
post <- post %>%
  mutate(rank = row_number())



# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create the base plot with all points--post-treatment

create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(pre, log2FC < -0.2 | log2FC > 0.2), 
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(pre, log2FC >= -0.2 & log2FC <= 0.2), 
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Costim/Coinhib Pre-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(pre, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2,
    ymax = significant_points$log2FC[i] + 0.2
  )
}

# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 21, 
                                                                     size = 5, 
                                                                     fill = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 21, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1, 
                       override.aes = list(shape = 21, 
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21, 
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('CostimCoinhibPathway_PreTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()







post <- post[!post$rowname.x == 'Mac_SPP1',]



sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")
create_label_grob <- function(sender, receiver, sender_color, receiver_color) {
  min_width <- 8 # Set a minimum width for the rectangles
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(min_width / 2, "npc"), height = unit(1, "lines"), just = "right")
  )
}
p <- ggplot(post, aes(x = rank, y = log2FC)) +
  # Add white dots for points outside -0.2 and 0.2
  geom_point(data = subset(post, log2FC < -0.2 | log2FC > 0.2), 
             color = "white", size = 2) +
  # Add black dots for points between -0.2 and 0.2
  geom_point(data = subset(post, log2FC >= -0.2 & log2FC <= 0.2), 
             color = "black", size = 1) +
  theme_classic() +
  labs(title = "Costim/Coinhib Post-ICB",
       x = "CCI rank", y = "log2FC(R/NR count)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 28),
        legend.position = "none", axis.text = element_text(size = 12),
        axis.title = element_text(size = 18, face = "bold"))

# Add custom annotations for log2FC > 0.2 or log2FC < -0.2
significant_points <- subset(post, log2FC > 0.2 | log2FC < -0.2)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$rowname.x[i],
    significant_points$receiver.x[i],
    sender_colors[significant_points$rowname.x[i]],
    receiver_colors[significant_points$receiver.x[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.75,  # Increased width of annotation
    xmax = significant_points$rank[i] + 0.75,
    ymin = significant_points$log2FC[i] - 0.2,
    ymax = significant_points$log2FC[i] + 0.2
  )
}

# Add horizontal lines at y = 0.2 and y = -0.2
p <- p + geom_hline(yintercept = c(-0.2, 0.2), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 21, 
                                                                     size = 5, 
                                                                     fill = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 21, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance and layout
p <- p + theme(
  legend.key = element_rect(colour = NA),
  legend.key.size = unit(1.2, "cm"),
  legend.text = element_text(size = 14),
  legend.title = element_text(size = 16, face = "bold"),
  legend.position = "none",
  legend.box = "vertical",
  legend.margin = margin(t = 0, r = 0, b = 0, l = 0),
  legend.box.margin = margin(0, 0, 0, 0),
  legend.spacing.x = unit(0, 'cm'),
  legend.spacing.y = unit(0, 'cm'),
  plot.margin = margin(t = 5, r = 5, b = 25, l = 5, unit = "pt")
)

# Adjust the guide for sender legend to use two rows, keep receiver legend as one row
p <- p + guides(
  color = guide_legend(nrow = 2, byrow = TRUE, order = 1, 
                       override.aes = list(shape = 21, 
                                           size = 6,
                                           fill = NA)),
  fill = guide_legend(nrow = 1, byrow = TRUE, order = 2,
                      override.aes = list(shape = 21, 
                                          size = 6,
                                          color = NA))
)

# Save the plot
pdf('CostimCoinhibPathway_PostTx_srlr_rankplot.pdf', width = 5.5, height = 5.5)
print(p)
dev.off()
```

```{r S3C--UpSet plot cDC1 sender}
load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma/all_cellchat_objs.rda')

#combined upset plots
create_combined_upset_plot <- function(cellchat, sender, target, group1, group2, desired_order, output_file) {
  library(dplyr)
  library(ComplexHeatmap)
  library(UpSetR)
  
  # Extract and prepare the interaction data for each group
  cellchat_count_group1 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group1]] %>% 
    select(c('target', 'ligand', 'receptor'))
  cellchat_count_group2 <- subsetCommunication(cellchat, sources.use = sender, targets.use = target)[[group2]] %>% 
    select(c('target', 'ligand', 'receptor'))
  
  # Create interaction string without the target/receiver
  cellchat_count_group1$interaction <- paste(cellchat_count_group1$ligand, cellchat_count_group1$receptor, sep = '->')
  cellchat_count_group2$interaction <- paste(cellchat_count_group2$ligand, cellchat_count_group2$receptor, sep = '->')
  
  # Create a list of interactions for each receiver
  interaction_list1 <- split(cellchat_count_group1$interaction, cellchat_count_group1$target)
  interaction_list2 <- split(cellchat_count_group2$interaction, cellchat_count_group2$target)
  
  # Filter out sets with a list length of zero
  interaction_list1 <- interaction_list1[sapply(interaction_list1, length) > 0]
  interaction_list2 <- interaction_list2[sapply(interaction_list2, length) > 0]
  
  # Append group IDs to the set names
  names(interaction_list1) <- paste(names(interaction_list1), group1, sep = "_")
  names(interaction_list2) <- paste(names(interaction_list2), group2, sep = "_")
  
  # Combine the interaction lists
  combined_interaction_list <- c(interaction_list1, interaction_list2)
  
  # Create a combination matrix
  comb_mat_combined <- make_comb_mat(combined_interaction_list)
  
  # Filter out empty columns (those with no intersection size)
  non_empty_columns <- comb_degree(comb_mat_combined) > 0
  comb_mat_combined_filtered <- comb_mat_combined[, non_empty_columns]
  
  # Create a custom color vector based on the set combinations
  intersection_colors <- sapply(seq_len(ncol(comb_mat_combined_filtered)), function(i) {
    sets_in_comb <- rownames(comb_mat_combined_filtered)[comb_mat_combined_filtered[,i] == 1]
    r_sets <- sum(grepl("_R$", sets_in_comb))
    nr_sets <- sum(grepl("_NR$", sets_in_comb))
    
    if (r_sets > 0 && nr_sets == 0) {
      return("#B71C1C")  # Color for "_R" only
    } else if (nr_sets > 0 && r_sets == 0) {
      return('#2196F3')  # Color for "_NR" only
    } else if (r_sets > 0 && nr_sets > 0) {
      return("grey20")  # Color for both
    } else {
      return("grey50")  # Default color
    }
  })
  
  # Generate the UpSet plot
  tryCatch({
    grDevices::pdf(output_file, width = 6, height = 4)
    print(UpSet(comb_mat_combined_filtered, 
                pt_size = unit(5, "mm"), 
                lwd = 3, 
                comb_col = intersection_colors, 
                bg_col = c("grey90", "grey100"), 
                bg_pt_col = "grey70",
                set_order = desired_order))
  }, finally = {
    grDevices::dev.off()
  })
  
  # Check if the file was created successfully
  if (file.exists(output_file) && file.size(output_file) > 4096) {
    message("PDF file created successfully: ", output_file)
  } else {
    warning("PDF file creation may have failed or file is too small: ", output_file)
  }
  
  # Sanity check: Create a table of the number of interactions per set
  interactions_per_set <- sapply(combined_interaction_list, length)
  interactions_table <- data.frame(
    Set = names(interactions_per_set),
    Number_of_Interactions = interactions_per_set
  )
  
  # Sanity check: Get contributing interactions for each set
  contributing_interactions <- lapply(names(combined_interaction_list), function(set_name) {
    data.frame(
      Set = set_name,
      Interaction = combined_interaction_list[[set_name]]
    )
  })
  contributing_interactions <- do.call(rbind, contributing_interactions)
  
  # Sanity check: Get intersections and their sizes
  intersections <- comb_size(comb_mat_combined_filtered)
  intersection_sizes <- data.frame(
    Intersection = names(intersections),
    Size = intersections
  )
  
  # Create a list of returned objects
  returned_objects <- list(
    interactions_table = interactions_table,
    contributing_interactions = contributing_interactions,
    intersection_sizes = intersection_sizes,
    comb_mat = comb_mat_combined_filtered, 
    combined_interaction_list = combined_interaction_list
  )
  
  # Return the list of objects
  return(returned_objects)
}


# Example usage
original_receivers = c('IL7R_CD4', 'ITGAE_CD8', 'GZMK_CD8', 'NR4A2_CD8', 'CXCL13_Tcells', 'Tregs')

# Duplicate the vector and append "_R" and "_NR"
receivers_R <- paste(original_receivers, "_R", sep = "")
receivers_NR <- paste(original_receivers, "_NR", sep = "")

# Combine and rearrange the order
combined_receivers <- c(receivers_NR, receivers_R)

dc_post <- create_combined_upset_plot(cellchat = post.cellchat, 
                           sender = 'cDC1_CLEC9A',
                           target = unique(grep('CD4|CD8|Tcells|Tregs', post.cellchat@meta$consensus_clusters, value = T)), 
                           group1 = "NR", 
                           group2 = "R", 
                           desired_order = combined_receivers, 
                           output_file = "post_tx_cDC1_combined_UpsetPlot.pdf")
dc_pre <- create_combined_upset_plot(cellchat = pre.cellchat, 
                                        sender = 'cDC1_CLEC9A',
                                        target = unique(grep('CD4|CD8|Tcells|Tregs', pre.cellchat@meta$consensus_clusters, value = T)), 
                                        group1 = "NR", 
                                        group2 = "R", 
                                        desired_order = combined_receivers, 
                                        output_file = "pre_tx_cDC1_combined_UpsetPlot.pdf")
```

```{r S4A--Rank plots Complement (R/NR)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_complement/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
post <- merge(r_post, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 1 ~ "R_enriched",
  pre$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 1 ~ "R_enriched",
  post$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 9 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--pre-treatment
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  geom_point(data = pre, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Pre-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(pre, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_pretx_srlr_rankplot.pdf', width = 12, height = 8)
print(p)
dev.off()




# Create the base plot with all points--post-treatment

create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 12 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(post, aes(x = rank, y = log2FC)) +
  geom_point(data = post, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Post-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(post, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_post_tx_srlr_rankplot.pdf', width = 12, height = 8)
print(p)
dev.off()
```

```{r S4B--Rank plots Costim/Coinhib (R/NR)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat/Luoma_costim_coinhib/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
pre <- merge(r_pre, nr_pre, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/NR_pre_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
post <- merge(r_post, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(R_post_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
pre$color_group <- case_when(
  pre$log2FC > 1 ~ "R_enriched",
  pre$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)

post$color_group <- case_when(
  post$log2FC > 1 ~ "R_enriched",
  post$log2FC < -1 ~ "NR_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--pre-treatment
p <- ggplot(pre, aes(x = rank, y = log2FC)) +
  geom_point(data = pre, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/coinhibitory interactions only: Pre-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(pre, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coinhib_pretx_srlr_rankplot.pdf', width = 16, height = 8)
print(p)
dev.off()




# Create the base plot with all points--post-treatment

create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(post, aes(x = rank, y = log2FC)) +
  geom_point(data = post, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/coinhibitory interactions only: Post-treatment cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(post, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coinhib_post_tx_srlr_rankplot.pdf', width = 16, height = 8)
print(p)
dev.off()

```

```{r S4C--Rank plot Chemokine (Pre/Post paired) }
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat_pairedonly/Luoma_cytokine/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
#nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
r <- merge(r_pre, r_post, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/R_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
nr <- merge(nr_pre, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(NR_pre_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
r$color_group <- case_when(
  r$log2FC > 1 ~ "PreTx_enriched",
  r$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)

nr$color_group <- case_when(
  nr$log2FC > 1 ~ "PreTx_enriched",
  nr$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 10 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--Responders
p <- ggplot(r, aes(x = rank, y = log2FC)) +
  geom_point(data = r, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Chemokine interactions only: Responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(Pre/Post Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(r, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Chemokine_paired_R_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()




# Create the base plot with all points--post-treatment

create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 9 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(nr, aes(x = rank, y = log2FC)) +
  geom_point(data = nr, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Chemokine interactions only: Non-responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(nr, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Chemokine_paired_NR_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()


```

```{r S4D--Rank plot Complement (Pre/Post paired)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(grid)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat_pairedonly/Luoma_complement/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
#nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
r <- merge(r_pre, r_post, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/R_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
nr <- merge(nr_pre, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(NR_pre_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
r$color_group <- case_when(
  r$log2FC > 1 ~ "PreTx_enriched",
  r$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)

nr$color_group <- case_when(
  nr$log2FC > 1 ~ "PreTx_enriched",
  nr$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 9 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--Responders
p <- ggplot(r, aes(x = rank, y = log2FC)) +
  geom_point(data = r, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(Pre/Post Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(r, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_Paired_R_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()



# Create the base plot with all points--post-treatment
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 7 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   #'Mac_IL1B' = "#7BAFDE", 
                   'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", 
                   #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(nr, aes(x = rank, y = log2FC)) +
  geom_point(data = nr, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Complement interactions only: Non-responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(nr, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Complement_Paired_NR_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()

```

```{r S4E--Rank plot Costim/Coinhib (Pre/Post paired)}
library(CellChat)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(grid)

color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72", "#B17BA6", "#FF7F00", "#FDB462", 
                    "#E7298A", "#E78AC3","#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D", "#E6AB02", 
                    "#7570B3", "#BEAED4", "#666666", "#999999", "#AA8282", "#D4B7B7", "#8600BF", "#BA5CE3", 
                    "#808000","#AEAE5C", "#1E90FF", "#00BFFF", "#56FF0D", "#FFFF00")

# Set working directory to the script's location (RStudio only) 
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

load('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/CellChat_pairedonly/Luoma_costim_coinhib/all_cellchat_objs.rda')

# keeping track of the subsets that we do/don't want to include
send <- grep('Mac|Mon|DC', levels(pre_cellchat@idents$joint), value = T)
rec <- grep('CD4|CD8|Treg|Tcells', levels(pre_cellchat@idents$joint), value = T)

# get objects that contain group name and interaction probability
nr_pre <- subsetCommunication(nr_pre_cellchat, sources.use = send, targets.use = rec) %>% 
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_pre_prob")
nr_post <- subsetCommunication(nr_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "NR_post_prob")
r_pre <- subsetCommunication(r_pre_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_pre_prob")
r_post <- subsetCommunication(r_post_cellchat, sources.use = send, targets.use = rec) %>%
  select(c('source', 'target', 'ligand', 'receptor', 'prob')) %>%
  unite(SRLR, c('source', 'target', 'ligand', 'receptor'), sep = '->') %>%
  rename("prob" = "R_post_prob")
#nr_post <- nr_post[-grep('SPP1', nr_post$SRLR),]
r_post <- r_post[-grep('SPP1', r_post$SRLR),]

# merge down to two objects and calculate log2FC and rank
r <- merge(r_pre, r_post, by = 'SRLR') %>%
  mutate(log2FC = log2(R_pre_prob/R_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')
nr <- merge(nr_pre, nr_post, by = 'SRLR')  %>%
  mutate(log2FC = log2(NR_pre_prob/NR_post_prob)) %>%
  arrange(desc(log2FC)) %>%
  mutate(rank = row_number()) %>%
  separate(SRLR, c('sender', 'receiver', 'ligand', 'receptor'), sep = '->')


# Create a color column
r$color_group <- case_when(
  r$log2FC > 1 ~ "PreTx_enriched",
  r$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)

nr$color_group <- case_when(
  nr$log2FC > 1 ~ "PreTx_enriched",
  nr$log2FC < -1 ~ "PostTx_enriched",
  TRUE ~ "Unchanged"
)


# Define colors for senders and receivers
sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")
receiver_colors <- c("ITGAE_CD8" = "#33A02C", "CXCL13_Tcells" = "#B2DF8A", 'Tregs' = "#55A1B1", 'GZMK_CD8' = "#8DD3C7", 
                     'IL7R_CD4' = "#7570B3", 'NR4A2_CD8' = "#BEAED4")

# Create a custom function to generate annotation grobs
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}



# Create the base plot with all points--Responders
p <- ggplot(r, aes(x = rank, y = log2FC)) +
  geom_point(data = r, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/Coinhibitory interactions only: Responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(Pre/Post Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(r, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coinhib_Paired_R_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()




# Create the base plot with all points--post-treatment
create_label_grob <- function(ligand, receptor, sender_color, receiver_color) {
  label <- paste(ligand, receptor, sep = " | ")
  text_width <- convertWidth(stringWidth(label), "npc", valueOnly = TRUE)
  min_width <- 50 # Set a minimum width for the rectangles
  adjusted_width <- max(text_width, min_width)
  grobTree(
    rectGrob(gp = gpar(fill = receiver_color, col = NA), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "left"),
    rectGrob(gp = gpar(fill = sender_color, col = NA), x = unit(0.5, "npc"), width = unit(adjusted_width / 2, "npc"), height = unit(1, "lines"), just = "right"),
    textGrob(label, x = 0.5, y = 0.5, just = "center", gp = gpar(col = "white"))
  )
}

sender_colors <- c("mregDC_LAMP3" = "#DC050C", "Mac_CXCL9" = "#FB8072", 'Blood-like_CD14_Mono' = "#1965B0",
                   'Mac_IL1B' = "#7BAFDE", 'cDC2_CD33' = "#882E72", 'Mac_IL1Bint' = "#B17BA6", #'CD16_Mono' = "#FF7F00", 
                   'cDC2_CD1C' = "#FDB462", 'cDC1_CLEC9A' = "#E7298A", 'Mono_TIL' = "#E78AC3", 'DC_pDC' = "#8600BF")

p <- ggplot(nr, aes(x = rank, y = log2FC)) +
  geom_point(data = nr, aes(color = sender, fill = receiver), shape = 21) +  # Plot all points with color and fill
  theme_classic() +
  labs(title = "Costimulatory/Coinhibitory interactions only: non-responder cell-cell interaction rank",
       x = "Cell-cell interaction rank", y = "log2FC(R/NR Cellchat probability score)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
        legend.position = "bottom", axis.text=element_text(size=12),
        axis.title=element_text(size=16,face="bold"))

# Add custom annotations for log2FC > 1 or log2FC < -1
significant_points <- subset(nr, log2FC > 1 | log2FC < -1)

for (i in 1:nrow(significant_points)) {
  label_grob <- create_label_grob(
    significant_points$ligand[i],
    significant_points$receptor[i],
    sender_colors[significant_points$sender[i]],
    receiver_colors[significant_points$receiver[i]]
  )
  
  p <- p + annotation_custom(
    grob = label_grob,
    xmin = significant_points$rank[i] - 0.5,
    xmax = significant_points$rank[i] + 0.5,
    ymin = significant_points$log2FC[i] - 0.5,
    ymax = significant_points$log2FC[i] + 0.5
  )
}

# Add horizontal lines at y = 1 and y = -1
p <- p + geom_hline(yintercept = c(-1, 1), linetype = "dashed", color = "grey")

# Add legends for sender and receiver colors with correct order and appearance
p <- p + scale_color_manual(name = "Sender", 
                            values = sender_colors, 
                            breaks = names(sender_colors),
                            guide = guide_legend(order = 1, 
                                                 override.aes = list(shape = 22, 
                                                                     size = 5, 
                                                                     fill = sender_colors, 
                                                                     color = NA))) +
  scale_fill_manual(name = "Receiver", 
                    values = receiver_colors, 
                    breaks = names(receiver_colors),
                    guide = guide_legend(order = 2, 
                                         override.aes = list(shape = 22, 
                                                             size = 5, 
                                                             color = NA)))

# Adjust legend appearance
p <- p + theme(legend.key = element_rect(colour = NA),
               legend.key.size = unit(1, "cm"),
               legend.text = element_text(size = 12),
               legend.title = element_text(size = 14, face = "bold"),
               legend.position = "bottom")

pdf('Costim_Coninhib_Paired_NR_srlr_rankplot.pdf', width = 16, height = 6)
print(p)
dev.off()

```

```{r S4F/G--DotPlots per neighborhood of LRs from 4C}
load("/Volumes/hqdinh2/Projects/HNC_SPORE/CosMX_TMA/CosMX_RNA_merged.rda")

CosMX_RNA_merged <- CosMX_RNA_merged %>%
  Seurat::AddMetaData(
    metadata = case_when(
      CosMX_RNA_merged$k10_NhCoord20_anno == "Tumor_Immune_Mixed" ~ 'Tumor_Immune_Tcell_High',
      CosMX_RNA_merged$k10_NhCoord20_anno == "Macrophage_High" ~ "Immune_Macrophage_High",
      CosMX_RNA_merged$k10_NhCoord20_anno == "DC_T_iCAF_Tumor_Mixed" ~ "ap_iCAF_Immune_Mixed",
      CosMX_RNA_merged$k10_NhCoord20_anno == "CAF_Immune_Mixed" ~ "myCAF_Immune_Mixed",
      TRUE ~ as.character(CosMX_RNA_merged$k10_NhCoord20_anno)
    ), col.name = "k10_NhCoord20_anno_new"
  )

 unique(CosMX_RNA_merged$k10_NhCoord20_anno_new)
#[1] "Bcell_Plasma"             "Endothelial"              "Tumor_Immune_Tcell_High" 
#[4] "ap_iCAF_Immune_Mixed"     "Immune_Macrophage_High"   "myCAF_Immune_Mixed"      
#[7] "CAFs"                     "Tumor_High"               "Myeloid_K17+_Tumor_Mixed"
 
immune_macrophage_high <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new == "Immune_Macrophage_High"]

p1 <- DotPlot(immune_macrophage_high[,grep('Mon|Mac|DC', immune_macrophage_high$annot_cluster2)], features = c('CXCL9', 'CXCL10', 'CXCL16', 'CCL5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

p2 <- DotPlot(immune_macrophage_high[,grep('CD4|CD8|Treg', immune_macrophage_high$annot_cluster2)], features = c('CXCR3', 'CXCR6', 'CCR5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

pdf('immune_macrophage_high_NH_CXCL_CCL_dotplot_by_response.pdf', width = 14, height = 4)
cowplot::plot_grid(p1, p2)
dev.off()
 
 
 

tumor_immune_tcell_high <- CosMX_RNA_merged[,CosMX_RNA_merged$k10_NhCoord20_anno_new == "Tumor_Immune_Tcell_High"]

p1 <- DotPlot(tumor_immune_tcell_high[,grep('Mon|Mac|DC', tumor_immune_tcell_high$annot_cluster2)], features = c('CXCL9', 'CXCL10', 'CXCL16', 'CCL5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

p2 <- DotPlot(tumor_immune_tcell_high[,grep('CD4|CD8|Treg', tumor_immune_tcell_high$annot_cluster2)], features = c('CXCR3', 'CXCR6', 'CCR5'), col.min = 0, cols = 'RdBu', split.by = 'Response', group.by = 'annot_cluster2')

pdf('tumor_immune_tcell_high_NH_CXCL_CCL_dotplot_by_response.pdf', width = 14, height = 4)
cowplot::plot_grid(p1, p2)
dev.off()
```

```{r S5A--Full labeled rank plot}
source('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/Scripts/LR_Rank_Functions.R')

# Load in list from calculation step and merge them into a single dataframe
resultList <- readRDS(file = '/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/LR_boxplots/SCDC_LR_Comparison.rds')
allSamples <- do.call(rbind, args = resultList)
allSamples$score <- as.numeric(allSamples$score)

chemokineInteractions <- read.csv('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/ChemokineInteractions.csv')

# Filter to LR interactions with more than 2 samples per response group
result <- allSamples %>% 
  filter(sample_id != 'ck17_209') %>%
  group_by(LR_pair, response) %>%
  summarise(
    sample_count = n(),
    mean_value = mean(score),
    .groups = 'drop'
  ) %>%
  filter(sample_count >= 2) %>% 
  group_by(LR_pair) %>% 
  filter(n() == 2) %>%
  summarise(mean_diff = (diff(mean_value)), .groups = 'drop') %>%
  arrange(desc(mean_diff))

rankplot <- result %>% 
  mutate(rank = rank(-mean_diff)) %>%  # Create rank based on mean_diff
  mutate(label_category = case_when(
    rank <= 10 ~ "top",
    rank > (n() - 10) ~ "bottom",
    TRUE ~ "middle"
  )) %>%
  mutate(label = ifelse(label_category != "middle", LR_pair, ''))

ggplot(data = rankplot, 
       aes(x = rank, y = mean_diff, 
           label = label,
           color = label_category,
           size = label_category,
           alpha = label_category)) + 
  # Plot grey dots first
  geom_point(data = subset(rankplot, label_category == "middle")) +
  # Plot colored dots second
  geom_point(data = subset(rankplot, label_category != "middle")) +
  scale_color_manual(values = c("top" = "red", "bottom" = "blue", "middle" = "grey")) +
  scale_size_manual(values = c("top" = 3, "bottom" = 3, "middle" = 2)) +
  scale_alpha_manual(values = c("top" = 1, "bottom" = 1, "middle" = 0.5)) +
  xlab('Ligand-Receptor Rank (Mean R vs NR Difference)') + 
  ylab('R-NR LR Mean CD45+ Spot Proportion') + 
  ggtitle('Mean Difference of CD45+ Spot LR Proportions (R-NR)') + 
  theme_classic() +
  # Plot labels last with increased repulsion
  geom_text_repel(data = subset(rankplot, label_category != "middle"), 
                  max.overlaps = Inf, 
                  show.legend = FALSE, 
                  force = 10,
                  nudge_x = 0.05,
                  nudge_y = 0.05,
                  direction = 'both',
                  box.padding = 0.5,
                  point.padding = 0.5,
                  segment.color = 'grey50') +
  theme_prism(base_size = 20) +
  theme(legend.position = "none")

ggsave('allInts_SCDC_LR_rank_mean_difference_top_bottom.pdf', width = 12, height = 8)
```

```{r S5B/C--Highlighted R- and NR-enriched interactions from S5A}
source('/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/Scripts/LR_Rank_Functions.R')

setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) 

# Print the current working directory (optional, for verification) 
print(getwd())

#Load in list from calculation step and merge them into a single dataframe
resultList<-readRDS(file = '/Volumes/hqdinh2/Lab_Manuscripts/INPREP_HNC_ICB_GolfinosOwens_etal_2025/Visium_figures/LR_boxplots/SCDC_LR_Comparison.rds')
allSamples<-do.call(rbind,args = resultList)
allSamples$score=as.numeric(allSamples$score)



library(ggplot2)
library(dplyr)
library(ggpubr)
library(cowplot)

# Function to create the plot
create_lr_plot <- function(allSamples, lr_pairs) {
  # Create LR_pair column
  lr_pairs_combined <- sapply(lr_pairs, function(pair) paste(pair[1], pair[2], sep="_"))
  
  # Filter data
  plot_data <- allSamples %>%
    filter(LR_pair %in% lr_pairs_combined, sample_id != 'ck17_209')
  
  # Create the plot
  g <- ggplot(data = plot_data, 
              aes(x = response, y = score, fill = response, color = response)) + 
    geom_boxplot(alpha = 0.5, outlier.size = 0) + 
    geom_jitter(alpha = 0.8) + 
    stat_compare_means() + 
    facet_wrap(~LR_pair, scales = "free_y") +
    theme_bw() +
    theme(axis.text.x = element_blank(), 
          axis.ticks.x = element_blank(), 
          axis.title.x = element_blank(), 
          strip.text = element_text(size = 12),
          legend.key.size = unit(1, 'cm'), 
          legend.title = element_text(size = 30), 
          legend.text = element_text(size = 20), 
          axis.text = element_text(size = 16),
          axis.title = element_text(size = 12), 
          legend.position = 'none') + 
    scale_shape_manual(values = 1:5) + 
    scale_fill_manual(name = 'ICB\nResponse', values = c('#2196F3', '#FF8A80')) +
    scale_color_manual(values = c('#2196F3', '#FF8A80')) +
    ylab('Proportion of LR spots among CD45+ spots') +
    xlab('ICB Response')
  
  return(g)
}

lr_pairs_r <- list(c('EFNB1', 'EHA4'), c('NRG1', 'ERBB3'), c('EFNA1', 'EPHA4'), c('SEMA6D', 'PLXNA1'), c('HLA-DQA1', 'CD4'), c('CXCL11', 'ACKR3'), c('DLL1', 'NOTCH1'), c('ENTPD1', 'ADORA2B'), c('TNF', 'TNFRSF1A'), c('GZMA', 'PARD3'))
plot_r <- create_lr_plot(allSamples, lr_pairs_r)

# Save the plot
pdf('R_LR_prop_CD45pos_spots.pdf', width = 7, height = 8)
print(plot_r)
dev.off()



lr_pairs_nr <- list(c('CXCL5', 'ACKR1'), c('CCL13', 'CCR1'), c('CADM3', 'CADM3'), c('CXCL2', 'ACKR1'), c('CCL13', 'ACKR1'), c('CXCL3', 'ACKR1'), c('CSF3', 'CSF3R'), c('CNTN1', 'NRCAM'), c('EREG', 'EGFR'), c('NECTIN1', 'CADM3'))
plot_nr <- create_lr_plot(allSamples, lr_pairs_nr)

# Save the plot
pdf('NR_LR_prop_CD45pos_spots.pdf', width = 8, height = 8)
print(plot_nr)
dev.off()

```

```{r S6--ligand and receptor heatmaps (Fig 4c highlights)}
library(pheatmap)
library(RColorBrewer)
library(edgeR)

# Load annotation data
ann_cd45 <- readxl::read_excel('/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/inputs/GSE226134_CD45_10__norm (1).xlsx')
ann_cd68 <- readxl::read_excel('/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/inputs/GSE226134_CD68_10__norm.xlsx')
ann_ck <- readxl::read_excel('/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/inputs/GSE226134_CK_10__norm.xlsx')

# Load GeoMx data
t <- readRDS("/Volumes/hqdinh2/Projects/Public_Data/Yale_HNC_GeoMxWTA/NanoStringGeoMxSet_objects/raw_Yale_geomx.RDS")
e <- exprs(t)
log <- log2(e+1)
test <- fData(t)

lr_pairs <- list(
  #c('CXCL9', 'CXCR3'),
  #c('CXCL10', 'CXCR3'),
  #c('CXCL16', 'CXCR6'),
  c('CCL5', 'CCR5'),
  c('IL16', 'CD4'),
  c('IL11', 'IL11RA'),
  c('CCL19', 'CCR7'),
  c('CCL21', 'CCR7'),
  c('CCL4', 'CCR5'),
  c('CCL3', 'CCR5'),
  c('CCL13', 'CCR1'),
  c('CCL3', 'CCR1'),
  c('CCL2', 'CCR2'),
  c('CCL8', 'CCR1'),
  c('CCL8', 'CCR2'),
  c('CXCL12', 'CXCR4'),
  c('IL1B', 'IL1R2'),
  c('IL1B', 'IL1R1'),
  c('IL1A', 'IL1R2'),
  c('CCL5', 'CCR1'),
  c('CCL15', 'CCR1')
)

# Function to prepare data for heatmap
prepare_heatmap_data <- function(geomx_data, gene_list, segment) {
  e <- exprs(geomx_data)
  log_data <- cpm(e, log = T)
  log_data <- scale(log_data)
  test_data <- fData(geomx_data)
  test2 <- pData(geomx_data)
  
  # Replace RTS_IDs with TargetNames
  rownames(log_data) <- test_data$TargetName[match(rownames(log_data), test_data$RTS_ID)]
  
  # Filter for specified segment
  segment_data <- test2[grepl(segment, test2$segment), ]
  
  # Subset expression data for the segment and specified genes
  gene_list <- intersect(gene_list, rownames(log_data))

  heatmap_data <- log_data[gene_list, rownames(segment_data)]
  
  
  # Transpose so that genes are rows and samples are columns
  heatmap_data <- t(heatmap_data)
  
  return(list(data = heatmap_data, metadata = segment_data))
}





# Extract ligands and receptors from lr_pairs
ligands <- unique(sapply(lr_pairs, `[`, 1))
receptors <- sapply(lr_pairs, `[`, 2)

# Prepare data for CD68 (ligands) heatmap
cd68_data <- prepare_heatmap_data(geomx_data = t, gene_list = ligands, segment = "Segment 1")

# Prepare data for CD45 (receptors) heatmap
cd45_data <- prepare_heatmap_data(t, receptors, "Segment 2")

# Create annotation data frame for CLINICAL_BENEFIT
annotation_df <- data.frame(CLINICAL_BENEFIT = cd68_data$metadata$CLINICAL_BENEFIT)
rownames(annotation_df) <- rownames(cd68_data$metadata)

library(ComplexHeatmap)
library(circlize)

# Create color scales
expr_colors <- colorRamp2(c(min(cd68_data$data), mean(cd68_data$data), max(cd68_data$data)), 
                          c("blue", "white", "red"))

anno_colors <- list(CLINICAL_BENEFIT = c("YES" = "red", "NO" = "blue"))

# Create annotation object
column_ha <- HeatmapAnnotation(
  CLINICAL_BENEFIT = annotation_df$CLINICAL_BENEFIT,
  col = anno_colors
)

cd68_data$data <- t(cd68_data$data)
cd45_data$data <- t(cd45_data$data)

annotation_df_cd45 <- data.frame(CLINICAL_BENEFIT = cd45_data$metadata$CLINICAL_BENEFIT)
rownames(annotation_df_cd45) <- rownames(cd45_data$metadata)

column_ha_cd45 <- HeatmapAnnotation(
  CLINICAL_BENEFIT = annotation_df_cd45$CLINICAL_BENEFIT,
  col = anno_colors
)

# Create CD68 (ligands) heatmap
cd68_heatmap <- Heatmap(cd68_data$data,
                        name = "Expression",
                        column_title = "CD68 Ligands Heatmap",
                        col = expr_colors,
                        top_annotation = column_ha,
                        show_column_names = FALSE,
                        show_row_names = TRUE,
                        cluster_rows = TRUE,
                        cluster_columns = FALSE,
                        column_split = annotation_df$CLINICAL_BENEFIT,
                        column_title_gp = gpar(fontsize = 14, fontface = "bold"))


# Create CD45 (receptors) heatmap
cd45_heatmap <- Heatmap(cd45_data$data,
                        name = "Expression",
                        column_title = "CD45 Receptors Heatmap",
                        col = expr_colors,
                        top_annotation = column_ha_cd45,
                        show_column_names = FALSE,
                        show_row_names = TRUE,
                        cluster_rows = TRUE,
                        cluster_columns = FALSE,
                        column_split = annotation_df_cd45$CLINICAL_BENEFIT,
                        column_title_gp = gpar(fontsize = 14, fontface = "bold"))

# Draw and save the heatmaps
pdf("CD68_ligands_heatmap.pdf", width = 10, height = 8)
draw(cd68_heatmap)
dev.off()

pdf("CD45_receptors_heatmap.pdf", width = 10, height = 8)
draw(cd45_heatmap)
dev.off()


```

